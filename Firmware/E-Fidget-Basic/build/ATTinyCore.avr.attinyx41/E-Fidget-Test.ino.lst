
/home/micha/.var/app/cc.arduino.IDE2/cache/arduino/sketches/9D0F44FD1CCD37CDD9EC2F6D40AAF707/E-Fidget-Test.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	23 c0       	rjmp	.+70     	; 0x48 <__ctors_end>
   2:	32 c0       	rjmp	.+100    	; 0x68 <__bad_interrupt>
   4:	31 c0       	rjmp	.+98     	; 0x68 <__bad_interrupt>
   6:	30 c0       	rjmp	.+96     	; 0x68 <__bad_interrupt>
   8:	2f c0       	rjmp	.+94     	; 0x68 <__bad_interrupt>
   a:	2e c0       	rjmp	.+92     	; 0x68 <__bad_interrupt>
   c:	2d c0       	rjmp	.+90     	; 0x68 <__bad_interrupt>
   e:	2c c0       	rjmp	.+88     	; 0x68 <__bad_interrupt>
  10:	2b c0       	rjmp	.+86     	; 0x68 <__bad_interrupt>
  12:	2a c0       	rjmp	.+84     	; 0x68 <__bad_interrupt>
  14:	29 c0       	rjmp	.+82     	; 0x68 <__bad_interrupt>
  16:	08 c1       	rjmp	.+528    	; 0x228 <__vector_11>
  18:	27 c0       	rjmp	.+78     	; 0x68 <__bad_interrupt>
  1a:	26 c0       	rjmp	.+76     	; 0x68 <__bad_interrupt>
  1c:	25 c0       	rjmp	.+74     	; 0x68 <__bad_interrupt>
  1e:	24 c0       	rjmp	.+72     	; 0x68 <__bad_interrupt>
  20:	23 c0       	rjmp	.+70     	; 0x68 <__bad_interrupt>
  22:	22 c0       	rjmp	.+68     	; 0x68 <__bad_interrupt>
  24:	21 c0       	rjmp	.+66     	; 0x68 <__bad_interrupt>
  26:	20 c0       	rjmp	.+64     	; 0x68 <__bad_interrupt>
  28:	1f c0       	rjmp	.+62     	; 0x68 <__bad_interrupt>
  2a:	1e c0       	rjmp	.+60     	; 0x68 <__bad_interrupt>
  2c:	1d c0       	rjmp	.+58     	; 0x68 <__bad_interrupt>
  2e:	1c c0       	rjmp	.+56     	; 0x68 <__bad_interrupt>
  30:	1b c0       	rjmp	.+54     	; 0x68 <__bad_interrupt>
  32:	1a c0       	rjmp	.+52     	; 0x68 <__bad_interrupt>
  34:	19 c0       	rjmp	.+50     	; 0x68 <__bad_interrupt>
  36:	18 c0       	rjmp	.+48     	; 0x68 <__bad_interrupt>
  38:	17 c0       	rjmp	.+46     	; 0x68 <__bad_interrupt>
  3a:	16 c0       	rjmp	.+44     	; 0x68 <__bad_interrupt>

0000003c <__trampolines_end>:
__trampolines_start():
  3c:	01 02       	muls	r16, r17
  3e:	04 08       	sbc	r0, r4
  40:	10 20       	and	r1, r0
  42:	40 80       	ld	r4, Z
  44:	04 02       	muls	r16, r20
  46:	01 08       	sbc	r0, r1

00000048 <__ctors_end>:
__dtors_end():
  48:	11 24       	eor	r1, r1
  4a:	1f be       	out	0x3f, r1	; 63
  4c:	cf ef       	ldi	r28, 0xFF	; 255
  4e:	d2 e0       	ldi	r29, 0x02	; 2
  50:	de bf       	out	0x3e, r29	; 62
  52:	cd bf       	out	0x3d, r28	; 61

00000054 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  54:	21 e0       	ldi	r18, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  56:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  58:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  5a:	01 c0       	rjmp	.+2      	; 0x5e <.do_clear_bss_start>

0000005c <.do_clear_bss_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  5c:	1d 92       	st	X+, r1

0000005e <.do_clear_bss_start>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  5e:	a9 30       	cpi	r26, 0x09	; 9
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  60:	b2 07       	cpc	r27, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  62:	e1 f7       	brne	.-8      	; 0x5c <.do_clear_bss_loop>
.do_clear_bss_start():
  64:	2b d1       	rcall	.+598    	; 0x2bc <main>
  66:	c1 c1       	rjmp	.+898    	; 0x3ea <_exit>

00000068 <__bad_interrupt>:
__vector_22():
  68:	cb cf       	rjmp	.-106    	; 0x0 <__vectors>

0000006a <digitalRead.constprop.0>:
digitalRead.constprop.0():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:248
#endif

int digitalRead(uint8_t pin)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
  6a:	e0 e4       	ldi	r30, 0x40	; 64
  6c:	f0 e0       	ldi	r31, 0x00	; 0
  6e:	e4 91       	lpm	r30, Z
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:259
  // "read" should *NEVER* change the behavior of the thing you're using it on.
  // That's why it's called "read" not "write". As an added bonus, sets the
  // stage for auto-fast-digitalRead() for compile time known pins.
  // turnOffPWM( pin );

  if (*portInputRegister(port) & bit) return HIGH;
  70:	89 b3       	in	r24, 0x19	; 25
  72:	e8 23       	and	r30, r24
  74:	81 e0       	ldi	r24, 0x01	; 1
  76:	90 e0       	ldi	r25, 0x00	; 0
  78:	11 f4       	brne	.+4      	; 0x7e <digitalRead.constprop.0+0x14>
  7a:	90 e0       	ldi	r25, 0x00	; 0
  7c:	80 e0       	ldi	r24, 0x00	; 0
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:261
  return LOW;
}
  7e:	08 95       	ret

00000080 <digitalWrite>:
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:185
void digitalWrite(uint8_t pin, uint8_t val)
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
  80:	e8 2f       	mov	r30, r24
  82:	f0 e0       	ldi	r31, 0x00	; 0
  84:	e4 5c       	subi	r30, 0xC4	; 196
  86:	ff 4f       	sbci	r31, 0xFF	; 255
  88:	e4 91       	lpm	r30, Z
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:147
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 4
    if ( pin == CORE_PWM3_PIN )
  8a:	83 30       	cpi	r24, 0x03	; 3
  8c:	19 f4       	brne	.+6      	; 0x94 <digitalWrite+0x14>
Timer1_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:328
  TCCR1A = (TCCR1A & ~MASK2(COM1A1,COM1A0)) | (com << COM1A0);
}

__attribute__((always_inline)) static inline void Timer1_SetCompareOutputModeB( timer1_com_t com )
{
  TCCR1A = (TCCR1A & ~MASK2(COM1B1,COM1B0)) | (com << COM1B0);
  8e:	8f b5       	in	r24, 0x2f	; 47
  90:	8f 7c       	andi	r24, 0xCF	; 207
  92:	8f bd       	out	0x2f, r24	; 47
  94:	9e 2f       	mov	r25, r30
  96:	90 95       	com	r25
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:199

  out = portOutputRegister(port);
  pue = portPullupRegister(port);

  if (val == LOW) {
    uint8_t oldSREG = SREG;
  98:	2f b7       	in	r18, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:198
  turnOffPWM( pin );

  out = portOutputRegister(port);
  pue = portPullupRegister(port);

  if (val == LOW) {
  9a:	61 11       	cpse	r22, r1
  9c:	0b c0       	rjmp	.+22     	; 0xb4 <digitalWrite+0x34>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:200
    uint8_t oldSREG = SREG;
    cli();
  9e:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:201
    *out &= ~bit;
  a0:	8b b3       	in	r24, 0x1b	; 27
  a2:	89 23       	and	r24, r25
  a4:	8b bb       	out	0x1b, r24	; 27
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:208
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
    *pue &= ~bit;
  a6:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
  aa:	89 23       	and	r24, r25
  ac:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:209
    SREG = oldSREG;
  b0:	2f bf       	out	0x3f, r18	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:211
  }
}
  b2:	08 95       	ret
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:206
    *out &= ~bit;
    *pue &= ~bit; //Turn off the pullups
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
  b4:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:207
    *out |= bit;
  b6:	8b b3       	in	r24, 0x1b	; 27
  b8:	e8 2b       	or	r30, r24
  ba:	eb bb       	out	0x1b, r30	; 27
  bc:	f4 cf       	rjmp	.-24     	; 0xa6 <digitalWrite+0x26>

000000be <pinMode>:
pinMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:41
void pinMode(uint8_t pin, uint8_t mode)
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin & 63));}
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
  be:	e8 2f       	mov	r30, r24
  c0:	f0 e0       	ldi	r31, 0x00	; 0
  c2:	e4 5c       	subi	r30, 0xC4	; 196
  c4:	ff 4f       	sbci	r31, 0xFF	; 255
  c6:	e4 91       	lpm	r30, Z
  c8:	8e 2f       	mov	r24, r30
  ca:	80 95       	com	r24
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:60
    *reg &= ~bit;
    *out &= ~bit;
    *pue &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
    uint8_t oldSREG = SREG;
  cc:	9f b7       	in	r25, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:59
                cli();
    *reg &= ~bit;
    *out &= ~bit;
    *pue &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
  ce:	62 30       	cpi	r22, 0x02	; 2
  d0:	71 f4       	brne	.+28     	; 0xee <pinMode+0x30>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:61
    uint8_t oldSREG = SREG;
                cli();
  d2:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:62
    *reg &= ~bit;
  d4:	2a b3       	in	r18, 0x1a	; 26
  d6:	82 23       	and	r24, r18
  d8:	8a bb       	out	0x1a, r24	; 26
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:63
    *out |= bit;
  da:	8b b3       	in	r24, 0x1b	; 27
  dc:	8e 2b       	or	r24, r30
  de:	8b bb       	out	0x1b, r24	; 27
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:64
    *pue |= bit;
  e0:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
  e4:	e8 2b       	or	r30, r24
  e6:	e0 93 63 00 	sts	0x0063, r30	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:71
  } else {
    uint8_t oldSREG = SREG;
                cli();
    *pue &= ~bit;
    *reg |= bit;
    SREG = oldSREG;
  ea:	9f bf       	out	0x3f, r25	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:73
  }
}
  ec:	08 95       	ret
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:68
    *out |= bit;
    *pue |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
                cli();
  ee:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:69
    *pue &= ~bit;
  f0:	20 91 63 00 	lds	r18, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
  f4:	82 23       	and	r24, r18
  f6:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:70
    *reg |= bit;
  fa:	8a b3       	in	r24, 0x1a	; 26
  fc:	e8 2b       	or	r30, r24
  fe:	ea bb       	out	0x1a, r30	; 26
 100:	f4 cf       	rjmp	.-24     	; 0xea <pinMode+0x2c>

00000102 <micros>:
micros():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:134
  return m;
}
unsigned long micros()
{
  unsigned long m;
  uint8_t oldSREG = SREG, t;
 102:	3f b7       	in	r19, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:136

  cli();
 104:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:137
  m = millis_timer_overflow_count;
 106:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <millis_timer_overflow_count>
 10a:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <millis_timer_overflow_count+0x1>
 10e:	a0 91 07 01 	lds	r26, 0x0107	; 0x800107 <millis_timer_overflow_count+0x2>
 112:	b0 91 08 01 	lds	r27, 0x0108	; 0x800108 <millis_timer_overflow_count+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:139
#if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
  t = TCNT0;
 116:	22 b7       	in	r18, 0x32	; 50
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:151
#else
  #error Millis()/Micros() timer not defined
#endif

#if defined(TIFR0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR0 & _BV(TOV0)) && (t < 255))
 118:	08 b6       	in	r0, 0x38	; 56
 11a:	00 fe       	sbrs	r0, 0
 11c:	05 c0       	rjmp	.+10     	; 0x128 <micros+0x26>
 11e:	2f 3f       	cpi	r18, 0xFF	; 255
 120:	19 f0       	breq	.+6      	; 0x128 <micros+0x26>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:152
    m++;
 122:	01 96       	adiw	r24, 0x01	; 1
 124:	a1 1d       	adc	r26, r1
 126:	b1 1d       	adc	r27, r1
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:164
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 1)
  if ((TIFR & _BV(TOV1)) && (t < 255))
    m++;
#endif

  SREG = oldSREG;
 128:	3f bf       	out	0x3f, r19	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:171

#if F_CPU < 1000000L
  return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
#else
#if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 ) // Can we just do it the naive way? If so great!
  return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
 12a:	ba 2f       	mov	r27, r26
 12c:	a9 2f       	mov	r26, r25
 12e:	98 2f       	mov	r25, r24
 130:	88 27       	eor	r24, r24
 132:	bc 01       	movw	r22, r24
 134:	cd 01       	movw	r24, r26
 136:	62 0f       	add	r22, r18
 138:	71 1d       	adc	r23, r1
 13a:	81 1d       	adc	r24, r1
 13c:	91 1d       	adc	r25, r1
 13e:	43 e0       	ldi	r20, 0x03	; 3
 140:	66 0f       	add	r22, r22
 142:	77 1f       	adc	r23, r23
 144:	88 1f       	adc	r24, r24
 146:	99 1f       	adc	r25, r25
 148:	4a 95       	dec	r20
 14a:	d1 f7       	brne	.-12     	; 0x140 <micros+0x3e>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:217
  //the high part gets divided by cCPuS then multiplied by the prescaler. Then take the low 8 bits plus the high part modulo-cCPuS to correct for the division, then multiply that by the prescaler value first before dividing by cCPuS, and finally add the two together.
  //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
  return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
#endif
#endif
}
 14c:	08 95       	ret

0000014e <delay>:
delay():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:225
  // Empty
}
void yield(void) __attribute__ ((weak, alias("__empty")));

void delay(unsigned long ms)
{
 14e:	cf 92       	push	r12
 150:	df 92       	push	r13
 152:	ef 92       	push	r14
 154:	ff 92       	push	r15
 156:	cf 93       	push	r28
 158:	df 93       	push	r29
 15a:	6b 01       	movw	r12, r22
 15c:	7c 01       	movw	r14, r24
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:227
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();
 15e:	d1 df       	rcall	.-94     	; 0x102 <micros>
 160:	eb 01       	movw	r28, r22
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:231

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
 162:	cf df       	rcall	.-98     	; 0x102 <micros>
 164:	6c 1b       	sub	r22, r28
 166:	7d 0b       	sbc	r23, r29
 168:	68 3e       	cpi	r22, 0xE8	; 232
 16a:	73 40       	sbci	r23, 0x03	; 3
 16c:	a0 f0       	brcs	.+40     	; 0x196 <delay+0x48>
 16e:	c1 14       	cp	r12, r1
 170:	d1 04       	cpc	r13, r1
 172:	e1 04       	cpc	r14, r1
 174:	f1 04       	cpc	r15, r1
 176:	39 f4       	brne	.+14     	; 0x186 <delay+0x38>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:241
  #else
  uint32_t start = millis();
  while((millis() - start) < ms)  /* NOP */yield();
  return;
  #endif
}
 178:	df 91       	pop	r29
 17a:	cf 91       	pop	r28
 17c:	ff 90       	pop	r15
 17e:	ef 90       	pop	r14
 180:	df 90       	pop	r13
 182:	cf 90       	pop	r12
 184:	08 95       	ret
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:232
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
      ms--;
 186:	81 e0       	ldi	r24, 0x01	; 1
 188:	c8 1a       	sub	r12, r24
 18a:	d1 08       	sbc	r13, r1
 18c:	e1 08       	sbc	r14, r1
 18e:	f1 08       	sbc	r15, r1
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:233
      start += 1000;
 190:	c8 51       	subi	r28, 0x18	; 24
 192:	dc 4f       	sbci	r29, 0xFC	; 252
 194:	e6 cf       	rjmp	.-52     	; 0x162 <delay+0x14>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:229
void delay(unsigned long ms)
{
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
 196:	c1 14       	cp	r12, r1
 198:	d1 04       	cpc	r13, r1
 19a:	e1 04       	cpc	r14, r1
 19c:	f1 04       	cpc	r15, r1
 19e:	09 f7       	brne	.-62     	; 0x162 <delay+0x14>
 1a0:	eb cf       	rjmp	.-42     	; 0x178 <delay+0x2a>

000001a2 <motorOn(unsigned char)>:
_Z7motorOnh():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:18
  digitalWrite(M3_PIN, LOW);


}

int motorOn(uint8_t pin) {
 1a2:	bf 92       	push	r11
 1a4:	cf 92       	push	r12
 1a6:	df 92       	push	r13
 1a8:	ef 92       	push	r14
 1aa:	ff 92       	push	r15
 1ac:	0f 93       	push	r16
 1ae:	1f 93       	push	r17
 1b0:	cf 93       	push	r28
 1b2:	df 93       	push	r29
 1b4:	b8 2e       	mov	r11, r24
millis():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:122
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
 1b6:	8f b7       	in	r24, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:126

  // disable interrupts while we read millis_timer_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
  cli();
 1b8:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:127
  m = millis_timer_millis;
 1ba:	c0 90 01 01 	lds	r12, 0x0101	; 0x800101 <millis_timer_millis>
 1be:	d0 90 02 01 	lds	r13, 0x0102	; 0x800102 <millis_timer_millis+0x1>
 1c2:	e0 90 03 01 	lds	r14, 0x0103	; 0x800103 <millis_timer_millis+0x2>
 1c6:	f0 90 04 01 	lds	r15, 0x0104	; 0x800104 <millis_timer_millis+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:128
  SREG = oldSREG;
 1ca:	8f bf       	out	0x3f, r24	; 63
delayMicroseconds():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:430


#endif

  // busy wait
  __asm__ __volatile__ (
 1cc:	0c e9       	ldi	r16, 0x9C	; 156
 1ce:	1f e0       	ldi	r17, 0x0F	; 15
 1d0:	c4 ec       	ldi	r28, 0xC4	; 196
 1d2:	d0 e0       	ldi	r29, 0x00	; 0
millis():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:122
}

unsigned long millis()
{
  unsigned long m;
  uint8_t oldSREG = SREG;
 1d4:	2f b7       	in	r18, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:126

  // disable interrupts while we read millis_timer_millis or we might get an
  // inconsistent value (e.g. in the middle of a write to millis_timer_millis)
  cli();
 1d6:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:127
  m = millis_timer_millis;
 1d8:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <millis_timer_millis>
 1dc:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <millis_timer_millis+0x1>
 1e0:	a0 91 03 01 	lds	r26, 0x0103	; 0x800103 <millis_timer_millis+0x2>
 1e4:	b0 91 04 01 	lds	r27, 0x0104	; 0x800104 <millis_timer_millis+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:128
  SREG = oldSREG;
 1e8:	2f bf       	out	0x3f, r18	; 63
_Z7motorOnh():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:19
  for (uint32_t tStart = millis(); (millis()-tStart) < ON_DELAY;) {
 1ea:	8c 19       	sub	r24, r12
 1ec:	9d 09       	sbc	r25, r13
 1ee:	ae 09       	sbc	r26, r14
 1f0:	bf 09       	sbc	r27, r15
 1f2:	05 97       	sbiw	r24, 0x05	; 5
 1f4:	a1 05       	cpc	r26, r1
 1f6:	b1 05       	cpc	r27, r1
 1f8:	68 f4       	brcc	.+26     	; 0x214 <motorOn(unsigned char)+0x72>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:20
    digitalWrite(pin, HIGH);
 1fa:	61 e0       	ldi	r22, 0x01	; 1
 1fc:	8b 2d       	mov	r24, r11
 1fe:	40 df       	rcall	.-384    	; 0x80 <digitalWrite>
delayMicroseconds():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:430


#endif

  // busy wait
  __asm__ __volatile__ (
 200:	c8 01       	movw	r24, r16
 202:	01 97       	sbiw	r24, 0x01	; 1
 204:	f1 f7       	brne	.-4      	; 0x202 <motorOn(unsigned char)+0x60>
_Z7motorOnh():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:22
    delayMicroseconds(2000);
    digitalWrite(pin, LOW);
 206:	60 e0       	ldi	r22, 0x00	; 0
 208:	8b 2d       	mov	r24, r11
 20a:	3a df       	rcall	.-396    	; 0x80 <digitalWrite>
delayMicroseconds():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:430
 20c:	ce 01       	movw	r24, r28
 20e:	01 97       	sbiw	r24, 0x01	; 1
 210:	f1 f7       	brne	.-4      	; 0x20e <motorOn(unsigned char)+0x6c>
 212:	e0 cf       	rjmp	.-64     	; 0x1d4 <motorOn(unsigned char)+0x32>
_Z7motorOnh():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:25
    delayMicroseconds(100);   
  }
}
 214:	df 91       	pop	r29
 216:	cf 91       	pop	r28
 218:	1f 91       	pop	r17
 21a:	0f 91       	pop	r16
 21c:	ff 90       	pop	r15
 21e:	ef 90       	pop	r14
 220:	df 90       	pop	r13
 222:	cf 90       	pop	r12
 224:	bf 90       	pop	r11
 226:	08 95       	ret

00000228 <__vector_11>:
__vector_11():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:86
volatile unsigned long millis_timer_overflow_count = 0;
volatile unsigned long millis_timer_millis = 0;
static unsigned char millis_timer_fract = 0;

ISR(MILLISTIMER_OVF_vect)
{
 228:	1f 92       	push	r1
 22a:	0f 92       	push	r0
 22c:	0f b6       	in	r0, 0x3f	; 63
 22e:	0f 92       	push	r0
 230:	11 24       	eor	r1, r1
 232:	2f 93       	push	r18
 234:	3f 93       	push	r19
 236:	8f 93       	push	r24
 238:	9f 93       	push	r25
 23a:	af 93       	push	r26
 23c:	bf 93       	push	r27
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:89
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
 23e:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <millis_timer_millis>
 242:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <millis_timer_millis+0x1>
 246:	a0 91 03 01 	lds	r26, 0x0103	; 0x800103 <millis_timer_millis+0x2>
 24a:	b0 91 04 01 	lds	r27, 0x0104	; 0x800104 <millis_timer_millis+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:90
  unsigned char f = millis_timer_fract;
 24e:	30 91 00 01 	lds	r19, 0x0100	; 0x800100 <_edata>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:102
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
 252:	26 e0       	ldi	r18, 0x06	; 6
 254:	23 0f       	add	r18, r19
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:104

  if (f >= FRACT_MAX)
 256:	2d 37       	cpi	r18, 0x7D	; 125
 258:	68 f1       	brcs	.+90     	; 0x2b4 <__vector_11+0x8c>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:106
  {
    f -= FRACT_MAX;
 25a:	29 e8       	ldi	r18, 0x89	; 137
 25c:	23 0f       	add	r18, r19
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:107
    m = m + MILLIS_INC + 1;
 25e:	03 96       	adiw	r24, 0x03	; 3
 260:	a1 1d       	adc	r26, r1
 262:	b1 1d       	adc	r27, r1
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:114
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
 264:	20 93 00 01 	sts	0x0100, r18	; 0x800100 <_edata>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:115
  millis_timer_millis = m;
 268:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <millis_timer_millis>
 26c:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <millis_timer_millis+0x1>
 270:	a0 93 03 01 	sts	0x0103, r26	; 0x800103 <millis_timer_millis+0x2>
 274:	b0 93 04 01 	sts	0x0104, r27	; 0x800104 <millis_timer_millis+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:116
  millis_timer_overflow_count++;
 278:	80 91 05 01 	lds	r24, 0x0105	; 0x800105 <millis_timer_overflow_count>
 27c:	90 91 06 01 	lds	r25, 0x0106	; 0x800106 <millis_timer_overflow_count+0x1>
 280:	a0 91 07 01 	lds	r26, 0x0107	; 0x800107 <millis_timer_overflow_count+0x2>
 284:	b0 91 08 01 	lds	r27, 0x0108	; 0x800108 <millis_timer_overflow_count+0x3>
 288:	01 96       	adiw	r24, 0x01	; 1
 28a:	a1 1d       	adc	r26, r1
 28c:	b1 1d       	adc	r27, r1
 28e:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <millis_timer_overflow_count>
 292:	90 93 06 01 	sts	0x0106, r25	; 0x800106 <millis_timer_overflow_count+0x1>
 296:	a0 93 07 01 	sts	0x0107, r26	; 0x800107 <millis_timer_overflow_count+0x2>
 29a:	b0 93 08 01 	sts	0x0108, r27	; 0x800108 <millis_timer_overflow_count+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:117
}
 29e:	bf 91       	pop	r27
 2a0:	af 91       	pop	r26
 2a2:	9f 91       	pop	r25
 2a4:	8f 91       	pop	r24
 2a6:	3f 91       	pop	r19
 2a8:	2f 91       	pop	r18
 2aa:	0f 90       	pop	r0
 2ac:	0f be       	out	0x3f, r0	; 63
 2ae:	0f 90       	pop	r0
 2b0:	1f 90       	pop	r1
 2b2:	18 95       	reti
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:111
    f -= FRACT_MAX;
    m = m + MILLIS_INC + 1;
  }
  else
  {
    m += MILLIS_INC;
 2b4:	02 96       	adiw	r24, 0x02	; 2
 2b6:	a1 1d       	adc	r26, r1
 2b8:	b1 1d       	adc	r27, r1
 2ba:	d4 cf       	rjmp	.-88     	; 0x264 <__vector_11+0x3c>

000002bc <main>:
main():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:491
  static uint8_t origOSC=0;

  uint8_t read_factory_calibration(void)
  {
    uint8_t SIGRD = 5; //Yes, this variable is needed. boot.h is looking for SIGRD but the io.h calls it RSIG... (unlike where this is needed in the other half of this core, at least the io.h file mentions it... ). Since it's actually a macro, not a function call, this works...
    uint8_t value = boot_signature_byte_get(1);
 2bc:	81 e2       	ldi	r24, 0x21	; 33
 2be:	e1 e0       	ldi	r30, 0x01	; 1
 2c0:	f0 e0       	ldi	r31, 0x00	; 0
 2c2:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
 2c6:	84 91       	lpm	r24, Z
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:560
    // jumping up about 174 from the factory cal gives us ~16 MHz at 4.5~5.25V - not always perfect, but should generally be close enough.
    origOSC=read_factory_calibration();
    oscBoost();
  #elif (CLOCK_SOURCE==0 && defined(LOWERCAL))
    origOSC=read_factory_calibration();
    oscSlow(origOSC-LOWERCAL);
 2c8:	81 50       	subi	r24, 0x01	; 1
oscSlow():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:495
    uint8_t SIGRD = 5; //Yes, this variable is needed. boot.h is looking for SIGRD but the io.h calls it RSIG... (unlike where this is needed in the other half of this core, at least the io.h file mentions it... ). Since it's actually a macro, not a function call, this works...
    uint8_t value = boot_signature_byte_get(1);
    return value;
  }
  void oscSlow(uint8_t newcal) {
    OSCCAL0=newcal;
 2ca:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__DATA_REGION_ORIGIN__+0x14>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:496
    _NOP(); //this is all micronucleus does, and it seems to work fine...
 2ce:	00 00       	nop
main():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:572
  #else
  CLKPR=1<<CLKPCE; //enable change of protected register
  #endif
  CLKPR=1; //prescale by 2 for 4MHz
  #endif
  sei();
 2d0:	78 94       	sei
Timer0_SetWaveformGenerationMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:140
}
timer0_wgm_t;

__attribute__((always_inline)) static inline void Timer0_SetWaveformGenerationMode( timer0_wgm_t wgm )
{
  TCCR0A = (TCCR0A & ~MASK2(WGM01,WGM00)) | (((wgm & B011) >> 0) << WGM00);
 2d2:	80 b7       	in	r24, 0x30	; 48
 2d4:	83 60       	ori	r24, 0x03	; 3
 2d6:	80 bf       	out	0x30, r24	; 48
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:141
  TCCR0B = (TCCR0B & ~MASK1(WGM02))       | (((wgm & B100) >> 2) << WGM02);
 2d8:	83 b7       	in	r24, 0x33	; 51
 2da:	87 7f       	andi	r24, 0xF7	; 247
 2dc:	83 bf       	out	0x33, r24	; 51
Timer0_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:122
}
timer0_cs_t;

__attribute__((always_inline)) static inline void Timer0_ClockSelect( timer0_cs_t cs )
{
  TCCR0B = (TCCR0B & ~MASK3(CS02,CS01,CS00)) | (cs << CS00);
 2de:	83 b7       	in	r24, 0x33	; 51
 2e0:	88 7f       	andi	r24, 0xF8	; 248
 2e2:	83 60       	ori	r24, 0x03	; 3
 2e4:	83 bf       	out	0x33, r24	; 51
Timer0_EnableOverflowInterrupt():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:198
  TIMSK0 |= (1<<OCIE0A);
}

__attribute__((always_inline)) static inline void Timer0_EnableOverflowInterrupt( void )
{
  TIMSK0 |= (1<<TOIE0);
 2e6:	89 b7       	in	r24, 0x39	; 57
 2e8:	81 60       	ori	r24, 0x01	; 1
 2ea:	89 bf       	out	0x39, r24	; 57
Timer2_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:470
}
timer2_cs_t;

__attribute__((always_inline)) static inline void Timer2_ClockSelect( timer2_cs_t cs )
{
  TCCR2B = (TCCR2B & ~MASK3(CS22,CS21,CS20)) | (cs << CS20);
 2ec:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
 2f0:	88 7f       	andi	r24, 0xF8	; 248
 2f2:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
Timer2_SetWaveformGenerationMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:496
}
timer2_wgm_t;

__attribute__((always_inline)) static inline void Timer2_SetWaveformGenerationMode( timer2_wgm_t wgm )
{
  TCCR2A = (TCCR2A & ~MASK2(WGM21,WGM20)) | (((wgm & B0011) >> 0) << WGM20);
 2f6:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
 2fa:	8c 7f       	andi	r24, 0xFC	; 252
 2fc:	81 60       	ori	r24, 0x01	; 1
 2fe:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:497
  TCCR2B = (TCCR2B & ~MASK2(WGM23,WGM22)) | (((wgm & B1100) >> 2) << WGM22);
 302:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
 306:	87 7e       	andi	r24, 0xE7	; 231
 308:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
Timer2_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:470
}
timer2_cs_t;

__attribute__((always_inline)) static inline void Timer2_ClockSelect( timer2_cs_t cs )
{
  TCCR2B = (TCCR2B & ~MASK3(CS22,CS21,CS20)) | (cs << CS20);
 30c:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
 310:	88 7f       	andi	r24, 0xF8	; 248
 312:	83 60       	ori	r24, 0x03	; 3
 314:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
Timer1_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:282
}
timer1_cs_t;

__attribute__((always_inline)) static inline void Timer1_ClockSelect( timer1_cs_t cs )
{
  TCCR1B = (TCCR1B & ~MASK3(CS12,CS11,CS10)) | (cs << CS10);
 318:	8e b5       	in	r24, 0x2e	; 46
 31a:	88 7f       	andi	r24, 0xF8	; 248
 31c:	8e bd       	out	0x2e, r24	; 46
Timer1_SetWaveformGenerationMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:308
}
timer1_wgm_t;

__attribute__((always_inline)) static inline void Timer1_SetWaveformGenerationMode( timer1_wgm_t wgm )
{
  TCCR1A = (TCCR1A & ~MASK2(WGM11,WGM10)) | (((wgm & B0011) >> 0) << WGM10);
 31e:	8f b5       	in	r24, 0x2f	; 47
 320:	8c 7f       	andi	r24, 0xFC	; 252
 322:	81 60       	ori	r24, 0x01	; 1
 324:	8f bd       	out	0x2f, r24	; 47
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:309
  TCCR1B = (TCCR1B & ~MASK2(WGM13,WGM12)) | (((wgm & B1100) >> 2) << WGM12);
 326:	8e b5       	in	r24, 0x2e	; 46
 328:	87 7e       	andi	r24, 0xE7	; 231
 32a:	8e bd       	out	0x2e, r24	; 46
Timer1_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:282
}
timer1_cs_t;

__attribute__((always_inline)) static inline void Timer1_ClockSelect( timer1_cs_t cs )
{
  TCCR1B = (TCCR1B & ~MASK3(CS12,CS11,CS10)) | (cs << CS10);
 32c:	8e b5       	in	r24, 0x2e	; 46
 32e:	88 7f       	andi	r24, 0xF8	; 248
 330:	83 60       	ori	r24, 0x03	; 3
 332:	8e bd       	out	0x2e, r24	; 46
initTimer841():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:468
  Timer1_SetWaveformGenerationMode(1);
  Timer1_ClockSelect(3);

  #endif

  TOCPMSA0=0b00010000;
 334:	80 e1       	ldi	r24, 0x10	; 16
 336:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <__DATA_REGION_ORIGIN__+0x7>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:469
  TOCPMSA1=0b10100100;
 33a:	84 ea       	ldi	r24, 0xA4	; 164
 33c:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:470
  TOCPMCOE=0b11111100;
 340:	8c ef       	ldi	r24, 0xFC	; 252
 342:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <__DATA_REGION_ORIGIN__+0x6>
ADC_PrescalerSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_adc.h:89
}
adc_ps_t;

__attribute__((always_inline)) static inline void ADC_PrescalerSelect( adc_ps_t ps )
{
  ADCSRA = (ADCSRA & ~MASK3(ADPS2,ADPS1,ADPS0)) | (ps << ADPS0);
 346:	85 b1       	in	r24, 0x05	; 5
 348:	88 7f       	andi	r24, 0xF8	; 248
 34a:	86 60       	ori	r24, 0x06	; 6
 34c:	85 b9       	out	0x05, r24	; 5
ADC_Enable():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_adc.h:94
}

__attribute__((always_inline)) static inline void ADC_Enable( void )
{
  ADCSRA |= MASK1( ADEN );
 34e:	2f 9a       	sbi	0x05, 7	; 5
setup():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:4
#include "Vars.h"

void setup() {
  pinMode(M1_PIN, OUTPUT);
 350:	61 e0       	ldi	r22, 0x01	; 1
 352:	81 e0       	ldi	r24, 0x01	; 1
 354:	b4 de       	rcall	.-664    	; 0xbe <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:5
  pinMode(M2_PIN, OUTPUT);
 356:	61 e0       	ldi	r22, 0x01	; 1
 358:	82 e0       	ldi	r24, 0x02	; 2
 35a:	b1 de       	rcall	.-670    	; 0xbe <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:6
  pinMode(M3_PIN, OUTPUT);
 35c:	61 e0       	ldi	r22, 0x01	; 1
 35e:	83 e0       	ldi	r24, 0x03	; 3
 360:	ae de       	rcall	.-676    	; 0xbe <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:8

  pinMode(B1_PIN, INPUT_PULLUP);
 362:	62 e0       	ldi	r22, 0x02	; 2
 364:	84 e0       	ldi	r24, 0x04	; 4
 366:	ab de       	rcall	.-682    	; 0xbe <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:9
  pinMode(B2_PIN, INPUT_PULLUP);
 368:	62 e0       	ldi	r22, 0x02	; 2
 36a:	85 e0       	ldi	r24, 0x05	; 5
 36c:	a8 de       	rcall	.-688    	; 0xbe <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:11

  digitalWrite(M1_PIN, LOW);
 36e:	60 e0       	ldi	r22, 0x00	; 0
 370:	81 e0       	ldi	r24, 0x01	; 1
 372:	86 de       	rcall	.-756    	; 0x80 <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:12
  digitalWrite(M2_PIN, LOW);
 374:	60 e0       	ldi	r22, 0x00	; 0
 376:	82 e0       	ldi	r24, 0x02	; 2
 378:	83 de       	rcall	.-762    	; 0x80 <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:13
  digitalWrite(M3_PIN, LOW);
 37a:	60 e0       	ldi	r22, 0x00	; 0
 37c:	83 e0       	ldi	r24, 0x03	; 3
 37e:	80 de       	rcall	.-768    	; 0x80 <digitalWrite>
loop():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:44
    delay(i * OFF_DELAY_MULTIPLIER);
  }
}

void loop() {
  if (digitalRead(B1_PIN) == BTN_ON) {
 380:	74 de       	rcall	.-792    	; 0x6a <digitalRead.constprop.0>
 382:	89 2b       	or	r24, r25
 384:	e9 f7       	brne	.-6      	; 0x380 <__stack+0x81>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:45
    while (digitalRead(B1_PIN) == BTN_ON) {
 386:	71 de       	rcall	.-798    	; 0x6a <digitalRead.constprop.0>
 388:	89 2b       	or	r24, r25
 38a:	31 f4       	brne	.+12     	; 0x398 <__stack+0x99>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:46
      delay(1);
 38c:	61 e0       	ldi	r22, 0x01	; 1
 38e:	70 e0       	ldi	r23, 0x00	; 0
 390:	80 e0       	ldi	r24, 0x00	; 0
 392:	90 e0       	ldi	r25, 0x00	; 0
 394:	dc de       	rcall	.-584    	; 0x14e <delay>
 396:	f7 cf       	rjmp	.-18     	; 0x386 <__stack+0x87>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:45
  }
}

void loop() {
  if (digitalRead(B1_PIN) == BTN_ON) {
    while (digitalRead(B1_PIN) == BTN_ON) {
 398:	83 e0       	ldi	r24, 0x03	; 3
 39a:	c8 2e       	mov	r12, r24
 39c:	d1 2c       	mov	r13, r1
 39e:	e1 2c       	mov	r14, r1
 3a0:	f1 2c       	mov	r15, r1
spin():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:29
  }
}

void spin() {
  for (int i=1; i<=10; i++) {
    motorOn(M1_PIN);
 3a2:	81 e0       	ldi	r24, 0x01	; 1
 3a4:	fe de       	rcall	.-516    	; 0x1a2 <motorOn(unsigned char)>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:30
    digitalWrite(M1_PIN, LOW);
 3a6:	60 e0       	ldi	r22, 0x00	; 0
 3a8:	81 e0       	ldi	r24, 0x01	; 1
 3aa:	6a de       	rcall	.-812    	; 0x80 <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:31
    delay(i * OFF_DELAY_MULTIPLIER);
 3ac:	c7 01       	movw	r24, r14
 3ae:	b6 01       	movw	r22, r12
 3b0:	ce de       	rcall	.-612    	; 0x14e <delay>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:33

    motorOn(M2_PIN);
 3b2:	82 e0       	ldi	r24, 0x02	; 2
 3b4:	f6 de       	rcall	.-532    	; 0x1a2 <motorOn(unsigned char)>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:34
    digitalWrite(M2_PIN, LOW);
 3b6:	60 e0       	ldi	r22, 0x00	; 0
 3b8:	82 e0       	ldi	r24, 0x02	; 2
 3ba:	62 de       	rcall	.-828    	; 0x80 <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:35
    delay(i * OFF_DELAY_MULTIPLIER);
 3bc:	c7 01       	movw	r24, r14
 3be:	b6 01       	movw	r22, r12
 3c0:	c6 de       	rcall	.-628    	; 0x14e <delay>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:37

    motorOn(M3_PIN);
 3c2:	83 e0       	ldi	r24, 0x03	; 3
 3c4:	ee de       	rcall	.-548    	; 0x1a2 <motorOn(unsigned char)>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:38
    digitalWrite(M3_PIN, LOW);
 3c6:	60 e0       	ldi	r22, 0x00	; 0
 3c8:	83 e0       	ldi	r24, 0x03	; 3
 3ca:	5a de       	rcall	.-844    	; 0x80 <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:39
    delay(i * OFF_DELAY_MULTIPLIER);
 3cc:	c7 01       	movw	r24, r14
 3ce:	b6 01       	movw	r22, r12
 3d0:	be de       	rcall	.-644    	; 0x14e <delay>
 3d2:	83 e0       	ldi	r24, 0x03	; 3
 3d4:	c8 0e       	add	r12, r24
 3d6:	d1 1c       	adc	r13, r1
 3d8:	e1 1c       	adc	r14, r1
 3da:	f1 1c       	adc	r15, r1
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test/E-Fidget-Test.ino:28
    delayMicroseconds(100);   
  }
}

void spin() {
  for (int i=1; i<=10; i++) {
 3dc:	81 e2       	ldi	r24, 0x21	; 33
 3de:	c8 16       	cp	r12, r24
 3e0:	d1 04       	cpc	r13, r1
 3e2:	e1 04       	cpc	r14, r1
 3e4:	f1 04       	cpc	r15, r1
 3e6:	e9 f6       	brne	.-70     	; 0x3a2 <__stack+0xa3>
 3e8:	cb cf       	rjmp	.-106    	; 0x380 <__stack+0x81>

000003ea <_exit>:
exit():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 3ea:	f8 94       	cli

000003ec <__stop_program>:
__stop_program():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 3ec:	ff cf       	rjmp	.-2      	; 0x3ec <__stop_program>
