
/home/micha/.var/app/cc.arduino.IDE2/cache/arduino/sketches/A3ECA98439BE908F3AA69315033D98EF/E-Fidget-Test.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	23 c0       	rjmp	.+70     	; 0x48 <__ctors_end>
   2:	32 c0       	rjmp	.+100    	; 0x68 <__bad_interrupt>
   4:	31 c0       	rjmp	.+98     	; 0x68 <__bad_interrupt>
   6:	30 c0       	rjmp	.+96     	; 0x68 <__bad_interrupt>
   8:	2f c0       	rjmp	.+94     	; 0x68 <__bad_interrupt>
   a:	2e c0       	rjmp	.+92     	; 0x68 <__bad_interrupt>
   c:	2d c0       	rjmp	.+90     	; 0x68 <__bad_interrupt>
   e:	2c c0       	rjmp	.+88     	; 0x68 <__bad_interrupt>
  10:	2b c0       	rjmp	.+86     	; 0x68 <__bad_interrupt>
  12:	2a c0       	rjmp	.+84     	; 0x68 <__bad_interrupt>
  14:	29 c0       	rjmp	.+82     	; 0x68 <__bad_interrupt>
  16:	c9 c0       	rjmp	.+402    	; 0x1aa <__vector_11>
  18:	27 c0       	rjmp	.+78     	; 0x68 <__bad_interrupt>
  1a:	26 c0       	rjmp	.+76     	; 0x68 <__bad_interrupt>
  1c:	25 c0       	rjmp	.+74     	; 0x68 <__bad_interrupt>
  1e:	24 c0       	rjmp	.+72     	; 0x68 <__bad_interrupt>
  20:	23 c0       	rjmp	.+70     	; 0x68 <__bad_interrupt>
  22:	22 c0       	rjmp	.+68     	; 0x68 <__bad_interrupt>
  24:	21 c0       	rjmp	.+66     	; 0x68 <__bad_interrupt>
  26:	20 c0       	rjmp	.+64     	; 0x68 <__bad_interrupt>
  28:	1f c0       	rjmp	.+62     	; 0x68 <__bad_interrupt>
  2a:	1e c0       	rjmp	.+60     	; 0x68 <__bad_interrupt>
  2c:	1d c0       	rjmp	.+58     	; 0x68 <__bad_interrupt>
  2e:	1c c0       	rjmp	.+56     	; 0x68 <__bad_interrupt>
  30:	1b c0       	rjmp	.+54     	; 0x68 <__bad_interrupt>
  32:	1a c0       	rjmp	.+52     	; 0x68 <__bad_interrupt>
  34:	19 c0       	rjmp	.+50     	; 0x68 <__bad_interrupt>
  36:	18 c0       	rjmp	.+48     	; 0x68 <__bad_interrupt>
  38:	17 c0       	rjmp	.+46     	; 0x68 <__bad_interrupt>
  3a:	16 c0       	rjmp	.+44     	; 0x68 <__bad_interrupt>

0000003c <__trampolines_end>:
__trampolines_start():
  3c:	01 02       	muls	r16, r17
  3e:	04 08       	sbc	r0, r4
  40:	10 20       	and	r1, r0
  42:	40 80       	ld	r4, Z
  44:	04 02       	muls	r16, r20
  46:	01 08       	sbc	r0, r1

00000048 <__ctors_end>:
__dtors_end():
  48:	11 24       	eor	r1, r1
  4a:	1f be       	out	0x3f, r1	; 63
  4c:	cf ef       	ldi	r28, 0xFF	; 255
  4e:	d2 e0       	ldi	r29, 0x02	; 2
  50:	de bf       	out	0x3e, r29	; 62
  52:	cd bf       	out	0x3d, r28	; 61

00000054 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  54:	21 e0       	ldi	r18, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  56:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  58:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  5a:	01 c0       	rjmp	.+2      	; 0x5e <.do_clear_bss_start>

0000005c <.do_clear_bss_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  5c:	1d 92       	st	X+, r1

0000005e <.do_clear_bss_start>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  5e:	a7 31       	cpi	r26, 0x17	; 23
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  60:	b2 07       	cpc	r27, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  62:	e1 f7       	brne	.-8      	; 0x5c <.do_clear_bss_loop>
.do_clear_bss_start():
  64:	ec d0       	rcall	.+472    	; 0x23e <main>
  66:	41 c2       	rjmp	.+1154   	; 0x4ea <_exit>

00000068 <__bad_interrupt>:
__vector_22():
  68:	cb cf       	rjmp	.-106    	; 0x0 <__vectors>

0000006a <digitalWrite>:
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:181
}

#if defined(__AVR_ATtinyX41__ ) || defined(__AVR_ATtiny1634__) || defined(__AVR_ATtiny828__)

void digitalWrite(uint8_t pin, uint8_t val)
{
  6a:	cf 93       	push	r28
  6c:	df 93       	push	r29
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:183
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  6e:	86 ff       	sbrs	r24, 6
  70:	06 c0       	rjmp	.+12     	; 0x7e <digitalWrite+0x14>
  72:	8f 73       	andi	r24, 0x3F	; 63
  74:	89 30       	cpi	r24, 0x09	; 9
  76:	18 f0       	brcs	.+6      	; 0x7e <digitalWrite+0x14>
  78:	8b 30       	cpi	r24, 0x0B	; 11
  7a:	91 f0       	breq	.+36     	; 0xa0 <digitalWrite+0x36>
  7c:	81 50       	subi	r24, 0x01	; 1
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:185
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
  7e:	e8 2f       	mov	r30, r24
  80:	f0 e0       	ldi	r31, 0x00	; 0
  82:	e4 5c       	subi	r30, 0xC4	; 196
  84:	ff 4f       	sbci	r31, 0xFF	; 255
  86:	e4 91       	lpm	r30, Z
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:186
  uint8_t port = digitalPinToPort(pin);
  88:	88 30       	cpi	r24, 0x08	; 8
  8a:	88 f4       	brcc	.+34     	; 0xae <digitalWrite+0x44>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:123
// each digitalread or write.
//
__attribute__((always_inline)) static inline void turnOffPWM( uint8_t pin )
{
  #if CORE_PWM_COUNT >= 1
    if ( pin == CORE_PWM0_PIN )
  8c:	84 30       	cpi	r24, 0x04	; 4
  8e:	51 f4       	brne	.+20     	; 0xa4 <digitalWrite+0x3a>
Timer0_SetCompareOutputModeA():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:155
}
timer0_com_t;

__attribute__((always_inline)) static inline void Timer0_SetCompareOutputModeA( timer0_com_t com )
{
  TCCR0A = (TCCR0A & ~MASK2(COM0A1,COM0A0)) | (com << COM0A0);
  90:	80 b7       	in	r24, 0x30	; 48
  92:	8f 73       	andi	r24, 0x3F	; 63
Timer0_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:161
}

__attribute__((always_inline)) static inline void Timer0_SetCompareOutputModeB( timer0_com_t com )
{

  TCCR0A = (TCCR0A & ~MASK2(COM0B1,COM0B0)) | (com << COM0B0);
  94:	80 bf       	out	0x30, r24	; 48
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:195

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  turnOffPWM( pin );

  out = portOutputRegister(port);
  96:	cb e3       	ldi	r28, 0x3B	; 59
  98:	d0 e0       	ldi	r29, 0x00	; 0
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:196
  pue = portPullupRegister(port);
  9a:	a3 e6       	ldi	r26, 0x63	; 99
  9c:	b0 e0       	ldi	r27, 0x00	; 0
  9e:	13 c0       	rjmp	.+38     	; 0xc6 <digitalWrite+0x5c>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:183
#if defined(__AVR_ATtinyX41__ ) || defined(__AVR_ATtiny1634__) || defined(__AVR_ATtiny828__)

void digitalWrite(uint8_t pin, uint8_t val)
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  a0:	89 e0       	ldi	r24, 0x09	; 9
  a2:	ed cf       	rjmp	.-38     	; 0x7e <digitalWrite+0x14>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:131
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 2
    if ( pin == CORE_PWM1_PIN )
  a4:	85 30       	cpi	r24, 0x05	; 5
  a6:	f9 f4       	brne	.+62     	; 0xe6 <digitalWrite+0x7c>
Timer0_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:161
  a8:	80 b7       	in	r24, 0x30	; 48
  aa:	8f 7c       	andi	r24, 0xCF	; 207
  ac:	f3 cf       	rjmp	.-26     	; 0x94 <digitalWrite+0x2a>
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:186
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);
  ae:	92 e0       	ldi	r25, 0x02	; 2
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:139
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 3
    if ( pin == CORE_PWM2_PIN )
  b0:	86 30       	cpi	r24, 0x06	; 6
  b2:	d9 f4       	brne	.+54     	; 0xea <digitalWrite+0x80>
Timer1_SetCompareOutputModeA():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:323
}
timer1_com_t;

__attribute__((always_inline)) static inline void Timer1_SetCompareOutputModeA( timer1_com_t com )
{
  TCCR1A = (TCCR1A & ~MASK2(COM1A1,COM1A0)) | (com << COM1A0);
  b4:	8f b5       	in	r24, 0x2f	; 47
  b6:	8f 73       	andi	r24, 0x3F	; 63
Timer1_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:328
}

__attribute__((always_inline)) static inline void Timer1_SetCompareOutputModeB( timer1_com_t com )
{
  TCCR1A = (TCCR1A & ~MASK2(COM1B1,COM1B0)) | (com << COM1B0);
  b8:	8f bd       	out	0x2f, r24	; 47
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:195

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  turnOffPWM( pin );

  out = portOutputRegister(port);
  ba:	91 30       	cpi	r25, 0x01	; 1
  bc:	61 f3       	breq	.-40     	; 0x96 <digitalWrite+0x2c>
  be:	c8 e3       	ldi	r28, 0x38	; 56
  c0:	d0 e0       	ldi	r29, 0x00	; 0
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:196
  pue = portPullupRegister(port);
  c2:	a2 e6       	ldi	r26, 0x62	; 98
  c4:	b0 e0       	ldi	r27, 0x00	; 0
  c6:	9e 2f       	mov	r25, r30
  c8:	90 95       	com	r25
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:199

  if (val == LOW) {
    uint8_t oldSREG = SREG;
  ca:	2f b7       	in	r18, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:198
  turnOffPWM( pin );

  out = portOutputRegister(port);
  pue = portPullupRegister(port);

  if (val == LOW) {
  cc:	61 11       	cpse	r22, r1
  ce:	20 c0       	rjmp	.+64     	; 0x110 <digitalWrite+0xa6>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:200
    uint8_t oldSREG = SREG;
    cli();
  d0:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:201
    *out &= ~bit;
  d2:	88 81       	ld	r24, Y
  d4:	89 23       	and	r24, r25
  d6:	88 83       	st	Y, r24
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:208
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
    *pue &= ~bit;
  d8:	8c 91       	ld	r24, X
  da:	89 23       	and	r24, r25
  dc:	8c 93       	st	X, r24
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:209
    SREG = oldSREG;
  de:	2f bf       	out	0x3f, r18	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:211
  }
}
  e0:	df 91       	pop	r29
  e2:	cf 91       	pop	r28
  e4:	08 95       	ret
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:186
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);
  e6:	91 e0       	ldi	r25, 0x01	; 1
  e8:	e3 cf       	rjmp	.-58     	; 0xb0 <digitalWrite+0x46>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:147
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 4
    if ( pin == CORE_PWM3_PIN )
  ea:	83 30       	cpi	r24, 0x03	; 3
  ec:	19 f4       	brne	.+6      	; 0xf4 <digitalWrite+0x8a>
Timer1_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:328
  ee:	8f b5       	in	r24, 0x2f	; 47
  f0:	8f 7c       	andi	r24, 0xCF	; 207
  f2:	e2 cf       	rjmp	.-60     	; 0xb8 <digitalWrite+0x4e>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:155
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 5
    if ( pin == CORE_PWM4_PIN )
  f4:	88 30       	cpi	r24, 0x08	; 8
  f6:	31 f4       	brne	.+12     	; 0x104 <digitalWrite+0x9a>
Timer2_SetCompareOutputModeA():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:511
}
timer2_com_t;

__attribute__((always_inline)) static inline void Timer2_SetCompareOutputModeA( timer2_com_t com )
{
  TCCR2A = (TCCR2A & ~MASK2(COM2A1,COM2A0)) | (com << COM2A0);
  f8:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
  fc:	8f 73       	andi	r24, 0x3F	; 63
Timer2_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:516
}

__attribute__((always_inline)) static inline void Timer2_SetCompareOutputModeB( timer2_com_t com )
{
  TCCR2A = (TCCR2A & ~MASK2(COM2B1,COM2B0)) | (com << COM2B0);
  fe:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
 102:	db cf       	rjmp	.-74     	; 0xba <digitalWrite+0x50>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:164
    else
  #endif

  #if CORE_PWM_COUNT >= 6

    if ( pin == CORE_PWM5_PIN )
 104:	87 30       	cpi	r24, 0x07	; 7
 106:	c9 f6       	brne	.-78     	; 0xba <digitalWrite+0x50>
Timer2_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:516
 108:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
 10c:	8f 7c       	andi	r24, 0xCF	; 207
 10e:	f7 cf       	rjmp	.-18     	; 0xfe <digitalWrite+0x94>
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:206
    *out &= ~bit;
    *pue &= ~bit; //Turn off the pullups
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 110:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:207
    *out |= bit;
 112:	88 81       	ld	r24, Y
 114:	e8 2b       	or	r30, r24
 116:	e8 83       	st	Y, r30
 118:	df cf       	rjmp	.-66     	; 0xd8 <digitalWrite+0x6e>

0000011a <pinMode>:
pinMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:41
void pinMode(uint8_t pin, uint8_t mode)
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin & 63));}
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
 11a:	e8 2f       	mov	r30, r24
 11c:	f0 e0       	ldi	r31, 0x00	; 0
 11e:	e4 5c       	subi	r30, 0xC4	; 196
 120:	ff 4f       	sbci	r31, 0xFF	; 255
 122:	e4 91       	lpm	r30, Z
 124:	8e 2f       	mov	r24, r30
 126:	80 95       	com	r24
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:60
    *reg &= ~bit;
    *out &= ~bit;
    *pue &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
    uint8_t oldSREG = SREG;
 128:	9f b7       	in	r25, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:59
                cli();
    *reg &= ~bit;
    *out &= ~bit;
    *pue &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
 12a:	62 30       	cpi	r22, 0x02	; 2
 12c:	71 f4       	brne	.+28     	; 0x14a <pinMode+0x30>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:61
    uint8_t oldSREG = SREG;
                cli();
 12e:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:62
    *reg &= ~bit;
 130:	2a b3       	in	r18, 0x1a	; 26
 132:	82 23       	and	r24, r18
 134:	8a bb       	out	0x1a, r24	; 26
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:63
    *out |= bit;
 136:	8b b3       	in	r24, 0x1b	; 27
 138:	8e 2b       	or	r24, r30
 13a:	8b bb       	out	0x1b, r24	; 27
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:64
    *pue |= bit;
 13c:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
 140:	e8 2b       	or	r30, r24
 142:	e0 93 63 00 	sts	0x0063, r30	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:71
  } else {
    uint8_t oldSREG = SREG;
                cli();
    *pue &= ~bit;
    *reg |= bit;
    SREG = oldSREG;
 146:	9f bf       	out	0x3f, r25	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:73
  }
}
 148:	08 95       	ret
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:68
    *out |= bit;
    *pue |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
                cli();
 14a:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:69
    *pue &= ~bit;
 14c:	20 91 63 00 	lds	r18, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
 150:	82 23       	and	r24, r18
 152:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:70
    *reg |= bit;
 156:	8a b3       	in	r24, 0x1a	; 26
 158:	e8 2b       	or	r30, r24
 15a:	ea bb       	out	0x1a, r30	; 26
 15c:	f4 cf       	rjmp	.-24     	; 0x146 <pinMode+0x2c>

0000015e <micros>:
micros():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:134
  return m;
}
unsigned long micros()
{
  unsigned long m;
  uint8_t oldSREG = SREG, t;
 15e:	3f b7       	in	r19, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:136

  cli();
 160:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:137
  m = millis_timer_overflow_count;
 162:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <millis_timer_overflow_count>
 166:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <millis_timer_overflow_count+0x1>
 16a:	a0 91 15 01 	lds	r26, 0x0115	; 0x800115 <millis_timer_overflow_count+0x2>
 16e:	b0 91 16 01 	lds	r27, 0x0116	; 0x800116 <millis_timer_overflow_count+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:139
#if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
  t = TCNT0;
 172:	22 b7       	in	r18, 0x32	; 50
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:151
#else
  #error Millis()/Micros() timer not defined
#endif

#if defined(TIFR0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR0 & _BV(TOV0)) && (t < 255))
 174:	08 b6       	in	r0, 0x38	; 56
 176:	00 fe       	sbrs	r0, 0
 178:	05 c0       	rjmp	.+10     	; 0x184 <micros+0x26>
 17a:	2f 3f       	cpi	r18, 0xFF	; 255
 17c:	19 f0       	breq	.+6      	; 0x184 <micros+0x26>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:152
    m++;
 17e:	01 96       	adiw	r24, 0x01	; 1
 180:	a1 1d       	adc	r26, r1
 182:	b1 1d       	adc	r27, r1
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:164
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 1)
  if ((TIFR & _BV(TOV1)) && (t < 255))
    m++;
#endif

  SREG = oldSREG;
 184:	3f bf       	out	0x3f, r19	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:171

#if F_CPU < 1000000L
  return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
#else
#if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 ) // Can we just do it the naive way? If so great!
  return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
 186:	ba 2f       	mov	r27, r26
 188:	a9 2f       	mov	r26, r25
 18a:	98 2f       	mov	r25, r24
 18c:	88 27       	eor	r24, r24
 18e:	bc 01       	movw	r22, r24
 190:	cd 01       	movw	r24, r26
 192:	62 0f       	add	r22, r18
 194:	71 1d       	adc	r23, r1
 196:	81 1d       	adc	r24, r1
 198:	91 1d       	adc	r25, r1
 19a:	43 e0       	ldi	r20, 0x03	; 3
 19c:	66 0f       	add	r22, r22
 19e:	77 1f       	adc	r23, r23
 1a0:	88 1f       	adc	r24, r24
 1a2:	99 1f       	adc	r25, r25
 1a4:	4a 95       	dec	r20
 1a6:	d1 f7       	brne	.-12     	; 0x19c <micros+0x3e>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:217
  //the high part gets divided by cCPuS then multiplied by the prescaler. Then take the low 8 bits plus the high part modulo-cCPuS to correct for the division, then multiply that by the prescaler value first before dividing by cCPuS, and finally add the two together.
  //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
  return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
#endif
#endif
}
 1a8:	08 95       	ret

000001aa <__vector_11>:
__vector_11():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:86
volatile unsigned long millis_timer_overflow_count = 0;
volatile unsigned long millis_timer_millis = 0;
static unsigned char millis_timer_fract = 0;

ISR(MILLISTIMER_OVF_vect)
{
 1aa:	1f 92       	push	r1
 1ac:	0f 92       	push	r0
 1ae:	0f b6       	in	r0, 0x3f	; 63
 1b0:	0f 92       	push	r0
 1b2:	11 24       	eor	r1, r1
 1b4:	2f 93       	push	r18
 1b6:	3f 93       	push	r19
 1b8:	8f 93       	push	r24
 1ba:	9f 93       	push	r25
 1bc:	af 93       	push	r26
 1be:	bf 93       	push	r27
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:89
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
 1c0:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <millis_timer_millis>
 1c4:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <millis_timer_millis+0x1>
 1c8:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <millis_timer_millis+0x2>
 1cc:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <millis_timer_millis+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:90
  unsigned char f = millis_timer_fract;
 1d0:	30 91 0e 01 	lds	r19, 0x010E	; 0x80010e <millis_timer_fract>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:102
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
 1d4:	26 e0       	ldi	r18, 0x06	; 6
 1d6:	23 0f       	add	r18, r19
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:104

  if (f >= FRACT_MAX)
 1d8:	2d 37       	cpi	r18, 0x7D	; 125
 1da:	68 f1       	brcs	.+90     	; 0x236 <__vector_11+0x8c>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:106
  {
    f -= FRACT_MAX;
 1dc:	29 e8       	ldi	r18, 0x89	; 137
 1de:	23 0f       	add	r18, r19
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:107
    m = m + MILLIS_INC + 1;
 1e0:	03 96       	adiw	r24, 0x03	; 3
 1e2:	a1 1d       	adc	r26, r1
 1e4:	b1 1d       	adc	r27, r1
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:114
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
 1e6:	20 93 0e 01 	sts	0x010E, r18	; 0x80010e <millis_timer_fract>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:115
  millis_timer_millis = m;
 1ea:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <millis_timer_millis>
 1ee:	90 93 10 01 	sts	0x0110, r25	; 0x800110 <millis_timer_millis+0x1>
 1f2:	a0 93 11 01 	sts	0x0111, r26	; 0x800111 <millis_timer_millis+0x2>
 1f6:	b0 93 12 01 	sts	0x0112, r27	; 0x800112 <millis_timer_millis+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:116
  millis_timer_overflow_count++;
 1fa:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <millis_timer_overflow_count>
 1fe:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <millis_timer_overflow_count+0x1>
 202:	a0 91 15 01 	lds	r26, 0x0115	; 0x800115 <millis_timer_overflow_count+0x2>
 206:	b0 91 16 01 	lds	r27, 0x0116	; 0x800116 <millis_timer_overflow_count+0x3>
 20a:	01 96       	adiw	r24, 0x01	; 1
 20c:	a1 1d       	adc	r26, r1
 20e:	b1 1d       	adc	r27, r1
 210:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <millis_timer_overflow_count>
 214:	90 93 14 01 	sts	0x0114, r25	; 0x800114 <millis_timer_overflow_count+0x1>
 218:	a0 93 15 01 	sts	0x0115, r26	; 0x800115 <millis_timer_overflow_count+0x2>
 21c:	b0 93 16 01 	sts	0x0116, r27	; 0x800116 <millis_timer_overflow_count+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:117
}
 220:	bf 91       	pop	r27
 222:	af 91       	pop	r26
 224:	9f 91       	pop	r25
 226:	8f 91       	pop	r24
 228:	3f 91       	pop	r19
 22a:	2f 91       	pop	r18
 22c:	0f 90       	pop	r0
 22e:	0f be       	out	0x3f, r0	; 63
 230:	0f 90       	pop	r0
 232:	1f 90       	pop	r1
 234:	18 95       	reti
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:111
    f -= FRACT_MAX;
    m = m + MILLIS_INC + 1;
  }
  else
  {
    m += MILLIS_INC;
 236:	02 96       	adiw	r24, 0x02	; 2
 238:	a1 1d       	adc	r26, r1
 23a:	b1 1d       	adc	r27, r1
 23c:	d4 cf       	rjmp	.-88     	; 0x1e6 <__vector_11+0x3c>

0000023e <main>:
main():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:491
  static uint8_t origOSC=0;

  uint8_t read_factory_calibration(void)
  {
    uint8_t SIGRD = 5; //Yes, this variable is needed. boot.h is looking for SIGRD but the io.h calls it RSIG... (unlike where this is needed in the other half of this core, at least the io.h file mentions it... ). Since it's actually a macro, not a function call, this works...
    uint8_t value = boot_signature_byte_get(1);
 23e:	81 e2       	ldi	r24, 0x21	; 33
 240:	e1 e0       	ldi	r30, 0x01	; 1
 242:	f0 e0       	ldi	r31, 0x00	; 0
 244:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
 248:	84 91       	lpm	r24, Z
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:560
    // jumping up about 174 from the factory cal gives us ~16 MHz at 4.5~5.25V - not always perfect, but should generally be close enough.
    origOSC=read_factory_calibration();
    oscBoost();
  #elif (CLOCK_SOURCE==0 && defined(LOWERCAL))
    origOSC=read_factory_calibration();
    oscSlow(origOSC-LOWERCAL);
 24a:	81 50       	subi	r24, 0x01	; 1
oscSlow():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:495
    uint8_t SIGRD = 5; //Yes, this variable is needed. boot.h is looking for SIGRD but the io.h calls it RSIG... (unlike where this is needed in the other half of this core, at least the io.h file mentions it... ). Since it's actually a macro, not a function call, this works...
    uint8_t value = boot_signature_byte_get(1);
    return value;
  }
  void oscSlow(uint8_t newcal) {
    OSCCAL0=newcal;
 24c:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__DATA_REGION_ORIGIN__+0x14>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:496
    _NOP(); //this is all micronucleus does, and it seems to work fine...
 250:	00 00       	nop
main():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:572
  #else
  CLKPR=1<<CLKPCE; //enable change of protected register
  #endif
  CLKPR=1; //prescale by 2 for 4MHz
  #endif
  sei();
 252:	78 94       	sei
Timer0_SetWaveformGenerationMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:140
}
timer0_wgm_t;

__attribute__((always_inline)) static inline void Timer0_SetWaveformGenerationMode( timer0_wgm_t wgm )
{
  TCCR0A = (TCCR0A & ~MASK2(WGM01,WGM00)) | (((wgm & B011) >> 0) << WGM00);
 254:	80 b7       	in	r24, 0x30	; 48
 256:	83 60       	ori	r24, 0x03	; 3
 258:	80 bf       	out	0x30, r24	; 48
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:141
  TCCR0B = (TCCR0B & ~MASK1(WGM02))       | (((wgm & B100) >> 2) << WGM02);
 25a:	83 b7       	in	r24, 0x33	; 51
 25c:	87 7f       	andi	r24, 0xF7	; 247
 25e:	83 bf       	out	0x33, r24	; 51
Timer0_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:122
}
timer0_cs_t;

__attribute__((always_inline)) static inline void Timer0_ClockSelect( timer0_cs_t cs )
{
  TCCR0B = (TCCR0B & ~MASK3(CS02,CS01,CS00)) | (cs << CS00);
 260:	83 b7       	in	r24, 0x33	; 51
 262:	88 7f       	andi	r24, 0xF8	; 248
 264:	83 60       	ori	r24, 0x03	; 3
 266:	83 bf       	out	0x33, r24	; 51
Timer0_EnableOverflowInterrupt():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:198
  TIMSK0 |= (1<<OCIE0A);
}

__attribute__((always_inline)) static inline void Timer0_EnableOverflowInterrupt( void )
{
  TIMSK0 |= (1<<TOIE0);
 268:	89 b7       	in	r24, 0x39	; 57
 26a:	81 60       	ori	r24, 0x01	; 1
 26c:	89 bf       	out	0x39, r24	; 57
Timer2_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:470
}
timer2_cs_t;

__attribute__((always_inline)) static inline void Timer2_ClockSelect( timer2_cs_t cs )
{
  TCCR2B = (TCCR2B & ~MASK3(CS22,CS21,CS20)) | (cs << CS20);
 26e:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
 272:	88 7f       	andi	r24, 0xF8	; 248
 274:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
Timer2_SetWaveformGenerationMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:496
}
timer2_wgm_t;

__attribute__((always_inline)) static inline void Timer2_SetWaveformGenerationMode( timer2_wgm_t wgm )
{
  TCCR2A = (TCCR2A & ~MASK2(WGM21,WGM20)) | (((wgm & B0011) >> 0) << WGM20);
 278:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
 27c:	8c 7f       	andi	r24, 0xFC	; 252
 27e:	81 60       	ori	r24, 0x01	; 1
 280:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:497
  TCCR2B = (TCCR2B & ~MASK2(WGM23,WGM22)) | (((wgm & B1100) >> 2) << WGM22);
 284:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
 288:	87 7e       	andi	r24, 0xE7	; 231
 28a:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
Timer2_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:470
}
timer2_cs_t;

__attribute__((always_inline)) static inline void Timer2_ClockSelect( timer2_cs_t cs )
{
  TCCR2B = (TCCR2B & ~MASK3(CS22,CS21,CS20)) | (cs << CS20);
 28e:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
 292:	88 7f       	andi	r24, 0xF8	; 248
 294:	83 60       	ori	r24, 0x03	; 3
 296:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
Timer1_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:282
}
timer1_cs_t;

__attribute__((always_inline)) static inline void Timer1_ClockSelect( timer1_cs_t cs )
{
  TCCR1B = (TCCR1B & ~MASK3(CS12,CS11,CS10)) | (cs << CS10);
 29a:	8e b5       	in	r24, 0x2e	; 46
 29c:	88 7f       	andi	r24, 0xF8	; 248
 29e:	8e bd       	out	0x2e, r24	; 46
Timer1_SetWaveformGenerationMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:308
}
timer1_wgm_t;

__attribute__((always_inline)) static inline void Timer1_SetWaveformGenerationMode( timer1_wgm_t wgm )
{
  TCCR1A = (TCCR1A & ~MASK2(WGM11,WGM10)) | (((wgm & B0011) >> 0) << WGM10);
 2a0:	8f b5       	in	r24, 0x2f	; 47
 2a2:	8c 7f       	andi	r24, 0xFC	; 252
 2a4:	81 60       	ori	r24, 0x01	; 1
 2a6:	8f bd       	out	0x2f, r24	; 47
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:309
  TCCR1B = (TCCR1B & ~MASK2(WGM13,WGM12)) | (((wgm & B1100) >> 2) << WGM12);
 2a8:	8e b5       	in	r24, 0x2e	; 46
 2aa:	87 7e       	andi	r24, 0xE7	; 231
 2ac:	8e bd       	out	0x2e, r24	; 46
Timer1_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:282
}
timer1_cs_t;

__attribute__((always_inline)) static inline void Timer1_ClockSelect( timer1_cs_t cs )
{
  TCCR1B = (TCCR1B & ~MASK3(CS12,CS11,CS10)) | (cs << CS10);
 2ae:	8e b5       	in	r24, 0x2e	; 46
 2b0:	88 7f       	andi	r24, 0xF8	; 248
 2b2:	83 60       	ori	r24, 0x03	; 3
 2b4:	8e bd       	out	0x2e, r24	; 46
initTimer841():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:468
  Timer1_SetWaveformGenerationMode(1);
  Timer1_ClockSelect(3);

  #endif

  TOCPMSA0=0b00010000;
 2b6:	80 e1       	ldi	r24, 0x10	; 16
 2b8:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <__DATA_REGION_ORIGIN__+0x7>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:469
  TOCPMSA1=0b10100100;
 2bc:	84 ea       	ldi	r24, 0xA4	; 164
 2be:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:470
  TOCPMCOE=0b11111100;
 2c2:	8c ef       	ldi	r24, 0xFC	; 252
 2c4:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <__DATA_REGION_ORIGIN__+0x6>
ADC_PrescalerSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_adc.h:89
}
adc_ps_t;

__attribute__((always_inline)) static inline void ADC_PrescalerSelect( adc_ps_t ps )
{
  ADCSRA = (ADCSRA & ~MASK3(ADPS2,ADPS1,ADPS0)) | (ps << ADPS0);
 2c8:	85 b1       	in	r24, 0x05	; 5
 2ca:	88 7f       	andi	r24, 0xF8	; 248
 2cc:	86 60       	ori	r24, 0x06	; 6
 2ce:	85 b9       	out	0x05, r24	; 5
ADC_Enable():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_adc.h:94
}

__attribute__((always_inline)) static inline void ADC_Enable( void )
{
  ADCSRA |= MASK1( ADEN );
 2d0:	2f 9a       	sbi	0x05, 7	; 5
setup():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:4
#include "Vars.h"

void setup() {
  pinMode(M1_PIN, OUTPUT);
 2d2:	61 e0       	ldi	r22, 0x01	; 1
 2d4:	81 e0       	ldi	r24, 0x01	; 1
 2d6:	21 df       	rcall	.-446    	; 0x11a <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:5
  pinMode(M2_PIN, OUTPUT);
 2d8:	61 e0       	ldi	r22, 0x01	; 1
 2da:	82 e0       	ldi	r24, 0x02	; 2
 2dc:	1e df       	rcall	.-452    	; 0x11a <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:6
  pinMode(M3_PIN, OUTPUT);
 2de:	61 e0       	ldi	r22, 0x01	; 1
 2e0:	83 e0       	ldi	r24, 0x03	; 3
 2e2:	1b df       	rcall	.-458    	; 0x11a <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:8

  pinMode(B1_PIN, INPUT_PULLUP);
 2e4:	62 e0       	ldi	r22, 0x02	; 2
 2e6:	84 e0       	ldi	r24, 0x04	; 4
 2e8:	18 df       	rcall	.-464    	; 0x11a <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:9
  pinMode(B2_PIN, INPUT_PULLUP);
 2ea:	62 e0       	ldi	r22, 0x02	; 2
 2ec:	85 e0       	ldi	r24, 0x05	; 5
 2ee:	15 df       	rcall	.-470    	; 0x11a <pinMode>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:11

  digitalWrite(M1_PIN, LOW);
 2f0:	60 e0       	ldi	r22, 0x00	; 0
 2f2:	81 e0       	ldi	r24, 0x01	; 1
 2f4:	ba de       	rcall	.-652    	; 0x6a <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:12
  digitalWrite(M2_PIN, LOW);
 2f6:	60 e0       	ldi	r22, 0x00	; 0
 2f8:	82 e0       	ldi	r24, 0x02	; 2
 2fa:	b7 de       	rcall	.-658    	; 0x6a <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:13
  digitalWrite(M3_PIN, LOW);
 2fc:	60 e0       	ldi	r22, 0x00	; 0
 2fe:	83 e0       	ldi	r24, 0x03	; 3
 300:	b4 de       	rcall	.-664    	; 0x6a <digitalWrite>
next_motor():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:44
}

void next_motor(unsigned long curtime)
{
    digitalWrite(curmotor, LOW);
    delaymode = 1;
 302:	01 e0       	ldi	r16, 0x01	; 1
 304:	10 e0       	ldi	r17, 0x00	; 0
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:52
    {
        curmotor = M2_PIN;
    }
    else if (curmotor == M2_PIN)
    {
        curmotor = M3_PIN;
 306:	83 e0       	ldi	r24, 0x03	; 3
 308:	88 2e       	mov	r8, r24
 30a:	91 2c       	mov	r9, r1
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:48
    digitalWrite(curmotor, LOW);
    delaymode = 1;
    event_time = curtime + (spin_count * 3 + curmotor) * DELAY_MULTIPLIER;
    if (curmotor == M1_PIN)
    {
        curmotor = M2_PIN;
 30c:	92 e0       	ldi	r25, 0x02	; 2
 30e:	a9 2e       	mov	r10, r25
 310:	b1 2c       	mov	r11, r1
digitalRead():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:248
#endif

int digitalRead(uint8_t pin)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
 312:	20 e4       	ldi	r18, 0x40	; 64
 314:	22 2e       	mov	r2, r18
 316:	20 e0       	ldi	r18, 0x00	; 0
 318:	32 2e       	mov	r3, r18
loop():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:85
    }
}

void loop()
{
    if (curmotor > 0)
 31a:	c0 91 0c 01 	lds	r28, 0x010C	; 0x80010c <curmotor>
 31e:	d0 91 0d 01 	lds	r29, 0x010D	; 0x80010d <curmotor+0x1>
 322:	1c 16       	cp	r1, r28
 324:	1d 06       	cpc	r1, r29
 326:	0c f0       	brlt	.+2      	; 0x32a <__stack+0x2b>
 328:	50 c0       	rjmp	.+160    	; 0x3ca <__stack+0xcb>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:87
    {
        unsigned long curtime = micros();
 32a:	19 df       	rcall	.-462    	; 0x15e <micros>
 32c:	6b 01       	movw	r12, r22
 32e:	7c 01       	movw	r14, r24
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:89

        if (curtime > event_time)
 330:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <event_time>
 334:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <event_time+0x1>
 338:	a0 91 0a 01 	lds	r26, 0x010A	; 0x80010a <event_time+0x2>
 33c:	b0 91 0b 01 	lds	r27, 0x010B	; 0x80010b <event_time+0x3>
 340:	8c 15       	cp	r24, r12
 342:	9d 05       	cpc	r25, r13
 344:	ae 05       	cpc	r26, r14
 346:	bf 05       	cpc	r27, r15
 348:	08 f0       	brcs	.+2      	; 0x34c <__stack+0x4d>
 34a:	3f c0       	rjmp	.+126    	; 0x3ca <__stack+0xcb>
next_event():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:71
    }
}

void next_event(unsigned long curtime)
{
    if (delaymode == 0)
 34c:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 350:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <_edata+0x1>
 354:	89 2b       	or	r24, r25
 356:	09 f0       	breq	.+2      	; 0x35a <__stack+0x5b>
 358:	94 c0       	rjmp	.+296    	; 0x482 <__LOCK_REGION_LENGTH__+0x82>
next_motor():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:43
    event_time = micros() + MOTOR_RUN_TIME;
}

void next_motor(unsigned long curtime)
{
    digitalWrite(curmotor, LOW);
 35a:	60 e0       	ldi	r22, 0x00	; 0
 35c:	8c 2f       	mov	r24, r28
 35e:	85 de       	rcall	.-758    	; 0x6a <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:44
    delaymode = 1;
 360:	10 93 01 01 	sts	0x0101, r17	; 0x800101 <_edata+0x1>
 364:	00 93 00 01 	sts	0x0100, r16	; 0x800100 <_edata>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:45
    event_time = curtime + (spin_count * 3 + curmotor) * DELAY_MULTIPLIER;
 368:	40 90 02 01 	lds	r4, 0x0102	; 0x800102 <spin_count>
 36c:	50 90 03 01 	lds	r5, 0x0103	; 0x800103 <spin_count+0x1>
 370:	60 90 04 01 	lds	r6, 0x0104	; 0x800104 <spin_count+0x2>
 374:	70 90 05 01 	lds	r7, 0x0105	; 0x800105 <spin_count+0x3>
 378:	23 e0       	ldi	r18, 0x03	; 3
 37a:	30 e0       	ldi	r19, 0x00	; 0
 37c:	40 e0       	ldi	r20, 0x00	; 0
 37e:	50 e0       	ldi	r21, 0x00	; 0
 380:	c3 01       	movw	r24, r6
 382:	b2 01       	movw	r22, r4
 384:	99 d0       	rcall	.+306    	; 0x4b8 <__mulsi3>
 386:	9e 01       	movw	r18, r28
 388:	0d 2e       	mov	r0, r29
 38a:	00 0c       	add	r0, r0
 38c:	44 0b       	sbc	r20, r20
 38e:	55 0b       	sbc	r21, r21
 390:	62 0f       	add	r22, r18
 392:	73 1f       	adc	r23, r19
 394:	84 1f       	adc	r24, r20
 396:	95 1f       	adc	r25, r21
 398:	28 ee       	ldi	r18, 0xE8	; 232
 39a:	33 e0       	ldi	r19, 0x03	; 3
 39c:	40 e0       	ldi	r20, 0x00	; 0
 39e:	50 e0       	ldi	r21, 0x00	; 0
 3a0:	8b d0       	rcall	.+278    	; 0x4b8 <__mulsi3>
 3a2:	c6 0e       	add	r12, r22
 3a4:	d7 1e       	adc	r13, r23
 3a6:	e8 1e       	adc	r14, r24
 3a8:	f9 1e       	adc	r15, r25
 3aa:	c0 92 08 01 	sts	0x0108, r12	; 0x800108 <event_time>
 3ae:	d0 92 09 01 	sts	0x0109, r13	; 0x800109 <event_time+0x1>
 3b2:	e0 92 0a 01 	sts	0x010A, r14	; 0x80010a <event_time+0x2>
 3b6:	f0 92 0b 01 	sts	0x010B, r15	; 0x80010b <event_time+0x3>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:46
    if (curmotor == M1_PIN)
 3ba:	c1 30       	cpi	r28, 0x01	; 1
 3bc:	d1 05       	cpc	r29, r1
 3be:	09 f0       	breq	.+2      	; 0x3c2 <__stack+0xc3>
 3c0:	3c c0       	rjmp	.+120    	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:48
    {
        curmotor = M2_PIN;
 3c2:	b0 92 0d 01 	sts	0x010D, r11	; 0x80010d <curmotor+0x1>
 3c6:	a0 92 0c 01 	sts	0x010C, r10	; 0x80010c <curmotor>
digitalRead():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:248
 3ca:	f1 01       	movw	r30, r2
 3cc:	84 91       	lpm	r24, Z
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:259
  // "read" should *NEVER* change the behavior of the thing you're using it on.
  // That's why it's called "read" not "write". As an added bonus, sets the
  // stage for auto-fast-digitalRead() for compile time known pins.
  // turnOffPWM( pin );

  if (*portInputRegister(port) & bit) return HIGH;
 3ce:	99 b3       	in	r25, 0x19	; 25
 3d0:	89 23       	and	r24, r25
 3d2:	09 f4       	brne	.+2      	; 0x3d6 <__stack+0xd7>
 3d4:	6c c0       	rjmp	.+216    	; 0x4ae <__LOCK_REGION_LENGTH__+0xae>
loop():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:99

    if (digitalRead(B1_PIN) == BTN_ON)
    {
        b1down = 1;
    }
    else if (b1down)
 3d6:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <b1down>
 3da:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <b1down+0x1>
 3de:	89 2b       	or	r24, r25
 3e0:	09 f4       	brne	.+2      	; 0x3e4 <__stack+0xe5>
 3e2:	9b cf       	rjmp	.-202    	; 0x31a <__stack+0x1b>
 3e4:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <curmotor>
 3e8:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <curmotor+0x1>
restart_motors():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:31

//int debounce = 0;

void restart_motors()
{
    spin_count = 0;
 3ec:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <spin_count>
 3f0:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <spin_count+0x1>
 3f4:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <spin_count+0x2>
 3f8:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <spin_count+0x3>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:32
    if (curmotor == 0)
 3fc:	89 2b       	or	r24, r25
 3fe:	39 f4       	brne	.+14     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:34
    {
        curmotor = M1_PIN;
 400:	10 93 0d 01 	sts	0x010D, r17	; 0x80010d <curmotor+0x1>
 404:	00 93 0c 01 	sts	0x010C, r16	; 0x80010c <curmotor>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:35
        digitalWrite(curmotor, HIGH);
 408:	61 e0       	ldi	r22, 0x01	; 1
 40a:	81 e0       	ldi	r24, 0x01	; 1
 40c:	2e de       	rcall	.-932    	; 0x6a <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:37
    }
    delaymode = 0;
 40e:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <_edata+0x1>
 412:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:38
    event_time = micros() + MOTOR_RUN_TIME;
 416:	a3 de       	rcall	.-698    	; 0x15e <micros>
 418:	68 57       	subi	r22, 0x78	; 120
 41a:	7c 4e       	sbci	r23, 0xEC	; 236
 41c:	8f 4f       	sbci	r24, 0xFF	; 255
 41e:	9f 4f       	sbci	r25, 0xFF	; 255
 420:	60 93 08 01 	sts	0x0108, r22	; 0x800108 <event_time>
 424:	70 93 09 01 	sts	0x0109, r23	; 0x800109 <event_time+0x1>
 428:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <event_time+0x2>
 42c:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <event_time+0x3>
loop():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:102
        b1down = 1;
    }
    else if (b1down)
    {
        restart_motors();
        b1down = 0;
 430:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <b1down+0x1>
 434:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <b1down>
 438:	70 cf       	rjmp	.-288    	; 0x31a <__stack+0x1b>
next_motor():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:50
    event_time = curtime + (spin_count * 3 + curmotor) * DELAY_MULTIPLIER;
    if (curmotor == M1_PIN)
    {
        curmotor = M2_PIN;
    }
    else if (curmotor == M2_PIN)
 43a:	22 97       	sbiw	r28, 0x02	; 2
 43c:	29 f4       	brne	.+10     	; 0x448 <__LOCK_REGION_LENGTH__+0x48>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:52
    {
        curmotor = M3_PIN;
 43e:	90 92 0d 01 	sts	0x010D, r9	; 0x80010d <curmotor+0x1>
 442:	80 92 0c 01 	sts	0x010C, r8	; 0x80010c <curmotor>
 446:	c1 cf       	rjmp	.-126    	; 0x3ca <__stack+0xcb>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:57
    }
    else
    {
        // curmotor == M3_PIN
        ++spin_count;
 448:	8f ef       	ldi	r24, 0xFF	; 255
 44a:	48 1a       	sub	r4, r24
 44c:	58 0a       	sbc	r5, r24
 44e:	68 0a       	sbc	r6, r24
 450:	78 0a       	sbc	r7, r24
 452:	40 92 02 01 	sts	0x0102, r4	; 0x800102 <spin_count>
 456:	50 92 03 01 	sts	0x0103, r5	; 0x800103 <spin_count+0x1>
 45a:	60 92 04 01 	sts	0x0104, r6	; 0x800104 <spin_count+0x2>
 45e:	70 92 05 01 	sts	0x0105, r7	; 0x800105 <spin_count+0x3>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:58
        if (spin_count >= 15)
 462:	ef e0       	ldi	r30, 0x0F	; 15
 464:	4e 16       	cp	r4, r30
 466:	51 04       	cpc	r5, r1
 468:	61 04       	cpc	r6, r1
 46a:	71 04       	cpc	r7, r1
 46c:	28 f0       	brcs	.+10     	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:60
        {
            curmotor = 0;
 46e:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <curmotor+0x1>
 472:	10 92 0c 01 	sts	0x010C, r1	; 0x80010c <curmotor>
 476:	a9 cf       	rjmp	.-174    	; 0x3ca <__stack+0xcb>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:64
        }
        else
        {
            curmotor = M1_PIN;
 478:	10 93 0d 01 	sts	0x010D, r17	; 0x80010d <curmotor+0x1>
 47c:	00 93 0c 01 	sts	0x010C, r16	; 0x80010c <curmotor>
 480:	a4 cf       	rjmp	.-184    	; 0x3ca <__stack+0xcb>
next_event():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:77
    {
        next_motor(curtime);
    }
    else
    {
        digitalWrite(curmotor, HIGH);
 482:	61 e0       	ldi	r22, 0x01	; 1
 484:	8c 2f       	mov	r24, r28
 486:	f1 dd       	rcall	.-1054   	; 0x6a <digitalWrite>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:78
        event_time = curtime + MOTOR_RUN_TIME;
 488:	f8 e8       	ldi	r31, 0x88	; 136
 48a:	cf 0e       	add	r12, r31
 48c:	f3 e1       	ldi	r31, 0x13	; 19
 48e:	df 1e       	adc	r13, r31
 490:	e1 1c       	adc	r14, r1
 492:	f1 1c       	adc	r15, r1
 494:	c0 92 08 01 	sts	0x0108, r12	; 0x800108 <event_time>
 498:	d0 92 09 01 	sts	0x0109, r13	; 0x800109 <event_time+0x1>
 49c:	e0 92 0a 01 	sts	0x010A, r14	; 0x80010a <event_time+0x2>
 4a0:	f0 92 0b 01 	sts	0x010B, r15	; 0x80010b <event_time+0x3>
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:79
        delaymode = 0;
 4a4:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <_edata+0x1>
 4a8:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
 4ac:	8e cf       	rjmp	.-228    	; 0x3ca <__stack+0xcb>
loop():
/home/micha/Documents/E-Fidget-Firmware/E-Fidget-Test (copy)/E-Fidget-Test/E-Fidget-Test.ino:97
        }
    }

    if (digitalRead(B1_PIN) == BTN_ON)
    {
        b1down = 1;
 4ae:	10 93 07 01 	sts	0x0107, r17	; 0x800107 <b1down+0x1>
 4b2:	00 93 06 01 	sts	0x0106, r16	; 0x800106 <b1down>
 4b6:	31 cf       	rjmp	.-414    	; 0x31a <__stack+0x1b>

000004b8 <__mulsi3>:
__mulsi3():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:445
 4b8:	ee 27       	eor	r30, r30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:446
 4ba:	ff 27       	eor	r31, r31

000004bc <__mulsi3_helper>:
__mulsi3_helper():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:451
 4bc:	aa 27       	eor	r26, r26
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:452
 4be:	bb 27       	eor	r27, r27
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:453
 4c0:	08 c0       	rjmp	.+16     	; 0x4d2 <__mulsi3_helper+0x16>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:457
 4c2:	a2 0f       	add	r26, r18
 4c4:	b3 1f       	adc	r27, r19
 4c6:	e4 1f       	adc	r30, r20
 4c8:	f5 1f       	adc	r31, r21
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:460
 4ca:	22 0f       	add	r18, r18
 4cc:	33 1f       	adc	r19, r19
 4ce:	44 1f       	adc	r20, r20
 4d0:	55 1f       	adc	r21, r21
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:463
 4d2:	96 95       	lsr	r25
 4d4:	87 95       	ror	r24
 4d6:	77 95       	ror	r23
 4d8:	67 95       	ror	r22
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:465
 4da:	98 f3       	brcs	.-26     	; 0x4c2 <__mulsi3_helper+0x6>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:467
 4dc:	70 40       	sbci	r23, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:468
 4de:	a9 f7       	brne	.-22     	; 0x4ca <__mulsi3_helper+0xe>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:469
 4e0:	00 97       	sbiw	r24, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:470
 4e2:	99 f7       	brne	.-26     	; 0x4ca <__mulsi3_helper+0xe>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:473
 4e4:	bd 01       	movw	r22, r26
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:474
 4e6:	cf 01       	movw	r24, r30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:480
 4e8:	08 95       	ret

000004ea <_exit>:
exit():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 4ea:	f8 94       	cli

000004ec <__stop_program>:
__stop_program():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 4ec:	ff cf       	rjmp	.-2      	; 0x4ec <__stop_program>
