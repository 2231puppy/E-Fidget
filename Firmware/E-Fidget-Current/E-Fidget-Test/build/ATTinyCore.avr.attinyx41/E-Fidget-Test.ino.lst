
/home/micha/.var/app/cc.arduino.IDE2/cache/arduino/sketches/56411A0BE22B544D2157A2006D539FC2/E-Fidget-Test.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	23 c0       	rjmp	.+70     	; 0x48 <__ctors_end>
   2:	1e c1       	rjmp	.+572    	; 0x240 <__vector_1>
   4:	31 c0       	rjmp	.+98     	; 0x68 <__bad_interrupt>
   6:	30 c0       	rjmp	.+96     	; 0x68 <__bad_interrupt>
   8:	2f c0       	rjmp	.+94     	; 0x68 <__bad_interrupt>
   a:	2e c0       	rjmp	.+92     	; 0x68 <__bad_interrupt>
   c:	2d c0       	rjmp	.+90     	; 0x68 <__bad_interrupt>
   e:	2c c0       	rjmp	.+88     	; 0x68 <__bad_interrupt>
  10:	2b c0       	rjmp	.+86     	; 0x68 <__bad_interrupt>
  12:	2a c0       	rjmp	.+84     	; 0x68 <__bad_interrupt>
  14:	29 c0       	rjmp	.+82     	; 0x68 <__bad_interrupt>
  16:	ca c0       	rjmp	.+404    	; 0x1ac <__vector_11>
  18:	27 c0       	rjmp	.+78     	; 0x68 <__bad_interrupt>
  1a:	26 c0       	rjmp	.+76     	; 0x68 <__bad_interrupt>
  1c:	25 c0       	rjmp	.+74     	; 0x68 <__bad_interrupt>
  1e:	24 c0       	rjmp	.+72     	; 0x68 <__bad_interrupt>
  20:	23 c0       	rjmp	.+70     	; 0x68 <__bad_interrupt>
  22:	22 c0       	rjmp	.+68     	; 0x68 <__bad_interrupt>
  24:	21 c0       	rjmp	.+66     	; 0x68 <__bad_interrupt>
  26:	20 c0       	rjmp	.+64     	; 0x68 <__bad_interrupt>
  28:	1f c0       	rjmp	.+62     	; 0x68 <__bad_interrupt>
  2a:	1e c0       	rjmp	.+60     	; 0x68 <__bad_interrupt>
  2c:	1d c0       	rjmp	.+58     	; 0x68 <__bad_interrupt>
  2e:	1c c0       	rjmp	.+56     	; 0x68 <__bad_interrupt>
  30:	1b c0       	rjmp	.+54     	; 0x68 <__bad_interrupt>
  32:	1a c0       	rjmp	.+52     	; 0x68 <__bad_interrupt>
  34:	19 c0       	rjmp	.+50     	; 0x68 <__bad_interrupt>
  36:	18 c0       	rjmp	.+48     	; 0x68 <__bad_interrupt>
  38:	17 c0       	rjmp	.+46     	; 0x68 <__bad_interrupt>
  3a:	16 c0       	rjmp	.+44     	; 0x68 <__bad_interrupt>

0000003c <__trampolines_end>:
__trampolines_start():
  3c:	01 02       	muls	r16, r17
  3e:	04 08       	sbc	r0, r4
  40:	10 20       	and	r1, r0
  42:	40 80       	ld	r4, Z
  44:	04 02       	muls	r16, r20
  46:	01 08       	sbc	r0, r1

00000048 <__ctors_end>:
__dtors_end():
  48:	11 24       	eor	r1, r1
  4a:	1f be       	out	0x3f, r1	; 63
  4c:	cf ef       	ldi	r28, 0xFF	; 255
  4e:	d2 e0       	ldi	r29, 0x02	; 2
  50:	de bf       	out	0x3e, r29	; 62
  52:	cd bf       	out	0x3d, r28	; 61

00000054 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  54:	21 e0       	ldi	r18, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  56:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  58:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  5a:	01 c0       	rjmp	.+2      	; 0x5e <.do_clear_bss_start>

0000005c <.do_clear_bss_loop>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  5c:	1d 92       	st	X+, r1

0000005e <.do_clear_bss_start>:
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  5e:	a9 31       	cpi	r26, 0x19	; 25
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  60:	b2 07       	cpc	r27, r18
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  62:	e1 f7       	brne	.-8      	; 0x5c <.do_clear_bss_loop>
.do_clear_bss_start():
  64:	1a d1       	rcall	.+564    	; 0x29a <main>
  66:	7b c2       	rjmp	.+1270   	; 0x55e <_exit>

00000068 <__bad_interrupt>:
__vector_22():
  68:	cb cf       	rjmp	.-106    	; 0x0 <__vectors>

0000006a <digitalWrite>:
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:181
}

#if defined(__AVR_ATtinyX41__ ) || defined(__AVR_ATtiny1634__) || defined(__AVR_ATtiny828__)

void digitalWrite(uint8_t pin, uint8_t val)
{
  6a:	cf 93       	push	r28
  6c:	df 93       	push	r29
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:183
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  6e:	86 ff       	sbrs	r24, 6
  70:	06 c0       	rjmp	.+12     	; 0x7e <digitalWrite+0x14>
  72:	8f 73       	andi	r24, 0x3F	; 63
  74:	89 30       	cpi	r24, 0x09	; 9
  76:	18 f0       	brcs	.+6      	; 0x7e <digitalWrite+0x14>
  78:	8b 30       	cpi	r24, 0x0B	; 11
  7a:	91 f0       	breq	.+36     	; 0xa0 <digitalWrite+0x36>
  7c:	81 50       	subi	r24, 0x01	; 1
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:185
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
  7e:	e8 2f       	mov	r30, r24
  80:	f0 e0       	ldi	r31, 0x00	; 0
  82:	e4 5c       	subi	r30, 0xC4	; 196
  84:	ff 4f       	sbci	r31, 0xFF	; 255
  86:	e4 91       	lpm	r30, Z
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:186
  uint8_t port = digitalPinToPort(pin);
  88:	88 30       	cpi	r24, 0x08	; 8
  8a:	88 f4       	brcc	.+34     	; 0xae <digitalWrite+0x44>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:123
// each digitalread or write.
//
__attribute__((always_inline)) static inline void turnOffPWM( uint8_t pin )
{
  #if CORE_PWM_COUNT >= 1
    if ( pin == CORE_PWM0_PIN )
  8c:	84 30       	cpi	r24, 0x04	; 4
  8e:	51 f4       	brne	.+20     	; 0xa4 <digitalWrite+0x3a>
Timer0_SetCompareOutputModeA():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:155
}
timer0_com_t;

__attribute__((always_inline)) static inline void Timer0_SetCompareOutputModeA( timer0_com_t com )
{
  TCCR0A = (TCCR0A & ~MASK2(COM0A1,COM0A0)) | (com << COM0A0);
  90:	80 b7       	in	r24, 0x30	; 48
  92:	8f 73       	andi	r24, 0x3F	; 63
Timer0_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:161
}

__attribute__((always_inline)) static inline void Timer0_SetCompareOutputModeB( timer0_com_t com )
{

  TCCR0A = (TCCR0A & ~MASK2(COM0B1,COM0B0)) | (com << COM0B0);
  94:	80 bf       	out	0x30, r24	; 48
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:195

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  turnOffPWM( pin );

  out = portOutputRegister(port);
  96:	cb e3       	ldi	r28, 0x3B	; 59
  98:	d0 e0       	ldi	r29, 0x00	; 0
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:196
  pue = portPullupRegister(port);
  9a:	a3 e6       	ldi	r26, 0x63	; 99
  9c:	b0 e0       	ldi	r27, 0x00	; 0
  9e:	13 c0       	rjmp	.+38     	; 0xc6 <digitalWrite+0x5c>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:183
#if defined(__AVR_ATtinyX41__ ) || defined(__AVR_ATtiny1634__) || defined(__AVR_ATtiny828__)

void digitalWrite(uint8_t pin, uint8_t val)
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  a0:	89 e0       	ldi	r24, 0x09	; 9
  a2:	ed cf       	rjmp	.-38     	; 0x7e <digitalWrite+0x14>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:131
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 2
    if ( pin == CORE_PWM1_PIN )
  a4:	85 30       	cpi	r24, 0x05	; 5
  a6:	f9 f4       	brne	.+62     	; 0xe6 <digitalWrite+0x7c>
Timer0_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:161
  a8:	80 b7       	in	r24, 0x30	; 48
  aa:	8f 7c       	andi	r24, 0xCF	; 207
  ac:	f3 cf       	rjmp	.-26     	; 0x94 <digitalWrite+0x2a>
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:186
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);
  ae:	92 e0       	ldi	r25, 0x02	; 2
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:139
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 3
    if ( pin == CORE_PWM2_PIN )
  b0:	86 30       	cpi	r24, 0x06	; 6
  b2:	d9 f4       	brne	.+54     	; 0xea <digitalWrite+0x80>
Timer1_SetCompareOutputModeA():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:323
}
timer1_com_t;

__attribute__((always_inline)) static inline void Timer1_SetCompareOutputModeA( timer1_com_t com )
{
  TCCR1A = (TCCR1A & ~MASK2(COM1A1,COM1A0)) | (com << COM1A0);
  b4:	8f b5       	in	r24, 0x2f	; 47
  b6:	8f 73       	andi	r24, 0x3F	; 63
Timer1_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:328
}

__attribute__((always_inline)) static inline void Timer1_SetCompareOutputModeB( timer1_com_t com )
{
  TCCR1A = (TCCR1A & ~MASK2(COM1B1,COM1B0)) | (com << COM1B0);
  b8:	8f bd       	out	0x2f, r24	; 47
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:195

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  turnOffPWM( pin );

  out = portOutputRegister(port);
  ba:	91 30       	cpi	r25, 0x01	; 1
  bc:	61 f3       	breq	.-40     	; 0x96 <digitalWrite+0x2c>
  be:	c8 e3       	ldi	r28, 0x38	; 56
  c0:	d0 e0       	ldi	r29, 0x00	; 0
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:196
  pue = portPullupRegister(port);
  c2:	a2 e6       	ldi	r26, 0x62	; 98
  c4:	b0 e0       	ldi	r27, 0x00	; 0
  c6:	9e 2f       	mov	r25, r30
  c8:	90 95       	com	r25
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:199

  if (val == LOW) {
    uint8_t oldSREG = SREG;
  ca:	2f b7       	in	r18, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:198
  turnOffPWM( pin );

  out = portOutputRegister(port);
  pue = portPullupRegister(port);

  if (val == LOW) {
  cc:	61 11       	cpse	r22, r1
  ce:	20 c0       	rjmp	.+64     	; 0x110 <digitalWrite+0xa6>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:200
    uint8_t oldSREG = SREG;
    cli();
  d0:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:201
    *out &= ~bit;
  d2:	88 81       	ld	r24, Y
  d4:	89 23       	and	r24, r25
  d6:	88 83       	st	Y, r24
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:208
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
    *pue &= ~bit;
  d8:	8c 91       	ld	r24, X
  da:	89 23       	and	r24, r25
  dc:	8c 93       	st	X, r24
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:209
    SREG = oldSREG;
  de:	2f bf       	out	0x3f, r18	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:211
  }
}
  e0:	df 91       	pop	r29
  e2:	cf 91       	pop	r28
  e4:	08 95       	ret
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:186
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin&63));}
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);
  e6:	91 e0       	ldi	r25, 0x01	; 1
  e8:	e3 cf       	rjmp	.-58     	; 0xb0 <digitalWrite+0x46>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:147
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 4
    if ( pin == CORE_PWM3_PIN )
  ea:	83 30       	cpi	r24, 0x03	; 3
  ec:	19 f4       	brne	.+6      	; 0xf4 <digitalWrite+0x8a>
Timer1_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:328
  ee:	8f b5       	in	r24, 0x2f	; 47
  f0:	8f 7c       	andi	r24, 0xCF	; 207
  f2:	e2 cf       	rjmp	.-60     	; 0xb8 <digitalWrite+0x4e>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:155
    }
    else
  #endif

  #if CORE_PWM_COUNT >= 5
    if ( pin == CORE_PWM4_PIN )
  f4:	88 30       	cpi	r24, 0x08	; 8
  f6:	31 f4       	brne	.+12     	; 0x104 <digitalWrite+0x9a>
Timer2_SetCompareOutputModeA():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:511
}
timer2_com_t;

__attribute__((always_inline)) static inline void Timer2_SetCompareOutputModeA( timer2_com_t com )
{
  TCCR2A = (TCCR2A & ~MASK2(COM2A1,COM2A0)) | (com << COM2A0);
  f8:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
  fc:	8f 73       	andi	r24, 0x3F	; 63
Timer2_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:516
}

__attribute__((always_inline)) static inline void Timer2_SetCompareOutputModeB( timer2_com_t com )
{
  TCCR2A = (TCCR2A & ~MASK2(COM2B1,COM2B0)) | (com << COM2B0);
  fe:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
 102:	db cf       	rjmp	.-74     	; 0xba <digitalWrite+0x50>
turnOffPWM():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:164
    else
  #endif

  #if CORE_PWM_COUNT >= 6

    if ( pin == CORE_PWM5_PIN )
 104:	87 30       	cpi	r24, 0x07	; 7
 106:	c9 f6       	brne	.-78     	; 0xba <digitalWrite+0x50>
Timer2_SetCompareOutputModeB():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:516
 108:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
 10c:	8f 7c       	andi	r24, 0xCF	; 207
 10e:	f7 cf       	rjmp	.-18     	; 0xfe <digitalWrite+0x94>
digitalWrite():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:206
    *out &= ~bit;
    *pue &= ~bit; //Turn off the pullups
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
 110:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:207
    *out |= bit;
 112:	88 81       	ld	r24, Y
 114:	e8 2b       	or	r30, r24
 116:	e8 83       	st	Y, r30
 118:	df cf       	rjmp	.-66     	; 0xd8 <digitalWrite+0x6e>

0000011a <pinMode>:
pinMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:41
void pinMode(uint8_t pin, uint8_t mode)
{
  #ifndef __AVR_ATtiny828__
  if (pin&64) {pin=analogInputToDigitalPin((pin & 63));}
  #endif
  uint8_t bit = digitalPinToBitMask(pin);
 11a:	e8 2f       	mov	r30, r24
 11c:	f0 e0       	ldi	r31, 0x00	; 0
 11e:	e4 5c       	subi	r30, 0xC4	; 196
 120:	ff 4f       	sbci	r31, 0xFF	; 255
 122:	e4 91       	lpm	r30, Z
 124:	8e 2f       	mov	r24, r30
 126:	80 95       	com	r24
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:60
    *reg &= ~bit;
    *out &= ~bit;
    *pue &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
    uint8_t oldSREG = SREG;
 128:	9f b7       	in	r25, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:59
                cli();
    *reg &= ~bit;
    *out &= ~bit;
    *pue &= ~bit;
    SREG = oldSREG;
  } else if (mode == INPUT_PULLUP) {
 12a:	62 30       	cpi	r22, 0x02	; 2
 12c:	71 f4       	brne	.+28     	; 0x14a <pinMode+0x30>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:61
    uint8_t oldSREG = SREG;
                cli();
 12e:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:62
    *reg &= ~bit;
 130:	2a b3       	in	r18, 0x1a	; 26
 132:	82 23       	and	r24, r18
 134:	8a bb       	out	0x1a, r24	; 26
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:63
    *out |= bit;
 136:	8b b3       	in	r24, 0x1b	; 27
 138:	8e 2b       	or	r24, r30
 13a:	8b bb       	out	0x1b, r24	; 27
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:64
    *pue |= bit;
 13c:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
 140:	e8 2b       	or	r30, r24
 142:	e0 93 63 00 	sts	0x0063, r30	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:71
  } else {
    uint8_t oldSREG = SREG;
                cli();
    *pue &= ~bit;
    *reg |= bit;
    SREG = oldSREG;
 146:	9f bf       	out	0x3f, r25	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:73
  }
}
 148:	08 95       	ret
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:68
    *out |= bit;
    *pue |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
                cli();
 14a:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:69
    *pue &= ~bit;
 14c:	20 91 63 00 	lds	r18, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
 150:	82 23       	and	r24, r18
 152:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:70
    *reg |= bit;
 156:	8a b3       	in	r24, 0x1a	; 26
 158:	e8 2b       	or	r30, r24
 15a:	ea bb       	out	0x1a, r30	; 26
 15c:	f4 cf       	rjmp	.-24     	; 0x146 <pinMode+0x2c>

0000015e <micros>:
micros():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:134
  return m;
}
unsigned long micros()
{
  unsigned long m;
  uint8_t oldSREG = SREG, t;
 15e:	3f b7       	in	r19, 0x3f	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:136

  cli();
 160:	f8 94       	cli
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:137
  m = millis_timer_overflow_count;
 162:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <millis_timer_overflow_count>
 166:	90 91 16 01 	lds	r25, 0x0116	; 0x800116 <millis_timer_overflow_count+0x1>
 16a:	a0 91 17 01 	lds	r26, 0x0117	; 0x800117 <millis_timer_overflow_count+0x2>
 16e:	b0 91 18 01 	lds	r27, 0x0118	; 0x800118 <millis_timer_overflow_count+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:139
#if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
  t = TCNT0;
 172:	22 b7       	in	r18, 0x32	; 50
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:151
#else
  #error Millis()/Micros() timer not defined
#endif

#if defined(TIFR0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR0 & _BV(TOV0)) && (t < 255))
 174:	08 b6       	in	r0, 0x38	; 56
 176:	00 fe       	sbrs	r0, 0
 178:	05 c0       	rjmp	.+10     	; 0x184 <micros+0x26>
 17a:	2f 3f       	cpi	r18, 0xFF	; 255
 17c:	19 f0       	breq	.+6      	; 0x184 <micros+0x26>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:152
    m++;
 17e:	01 96       	adiw	r24, 0x01	; 1
 180:	a1 1d       	adc	r26, r1
 182:	b1 1d       	adc	r27, r1
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:164
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 1)
  if ((TIFR & _BV(TOV1)) && (t < 255))
    m++;
#endif

  SREG = oldSREG;
 184:	3f bf       	out	0x3f, r19	; 63
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:171

#if F_CPU < 1000000L
  return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
#else
#if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 ) // Can we just do it the naive way? If so great!
  return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
 186:	ba 2f       	mov	r27, r26
 188:	a9 2f       	mov	r26, r25
 18a:	98 2f       	mov	r25, r24
 18c:	88 27       	eor	r24, r24
 18e:	bc 01       	movw	r22, r24
 190:	cd 01       	movw	r24, r26
 192:	62 0f       	add	r22, r18
 194:	71 1d       	adc	r23, r1
 196:	81 1d       	adc	r24, r1
 198:	91 1d       	adc	r25, r1
 19a:	43 e0       	ldi	r20, 0x03	; 3
 19c:	66 0f       	add	r22, r22
 19e:	77 1f       	adc	r23, r23
 1a0:	88 1f       	adc	r24, r24
 1a2:	99 1f       	adc	r25, r25
 1a4:	4a 95       	dec	r20
 1a6:	d1 f7       	brne	.-12     	; 0x19c <micros+0x3e>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:217
  //the high part gets divided by cCPuS then multiplied by the prescaler. Then take the low 8 bits plus the high part modulo-cCPuS to correct for the division, then multiply that by the prescaler value first before dividing by cCPuS, and finally add the two together.
  //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
  return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
#endif
#endif
}
 1a8:	08 95       	ret

000001aa <wake()>:
_Z4wakev():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:22
  digitalWrite(M3_PIN, LOW);


}

void wake() { }
 1aa:	08 95       	ret

000001ac <__vector_11>:
__vector_11():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:86
volatile unsigned long millis_timer_overflow_count = 0;
volatile unsigned long millis_timer_millis = 0;
static unsigned char millis_timer_fract = 0;

ISR(MILLISTIMER_OVF_vect)
{
 1ac:	1f 92       	push	r1
 1ae:	0f 92       	push	r0
 1b0:	0f b6       	in	r0, 0x3f	; 63
 1b2:	0f 92       	push	r0
 1b4:	11 24       	eor	r1, r1
 1b6:	2f 93       	push	r18
 1b8:	3f 93       	push	r19
 1ba:	8f 93       	push	r24
 1bc:	9f 93       	push	r25
 1be:	af 93       	push	r26
 1c0:	bf 93       	push	r27
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:89
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
 1c2:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <millis_timer_millis>
 1c6:	90 91 12 01 	lds	r25, 0x0112	; 0x800112 <millis_timer_millis+0x1>
 1ca:	a0 91 13 01 	lds	r26, 0x0113	; 0x800113 <millis_timer_millis+0x2>
 1ce:	b0 91 14 01 	lds	r27, 0x0114	; 0x800114 <millis_timer_millis+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:90
  unsigned char f = millis_timer_fract;
 1d2:	30 91 10 01 	lds	r19, 0x0110	; 0x800110 <millis_timer_fract>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:102
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
 1d6:	26 e0       	ldi	r18, 0x06	; 6
 1d8:	23 0f       	add	r18, r19
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:104

  if (f >= FRACT_MAX)
 1da:	2d 37       	cpi	r18, 0x7D	; 125
 1dc:	68 f1       	brcs	.+90     	; 0x238 <__vector_11+0x8c>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:106
  {
    f -= FRACT_MAX;
 1de:	29 e8       	ldi	r18, 0x89	; 137
 1e0:	23 0f       	add	r18, r19
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:107
    m = m + MILLIS_INC + 1;
 1e2:	03 96       	adiw	r24, 0x03	; 3
 1e4:	a1 1d       	adc	r26, r1
 1e6:	b1 1d       	adc	r27, r1
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:114
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
 1e8:	20 93 10 01 	sts	0x0110, r18	; 0x800110 <millis_timer_fract>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:115
  millis_timer_millis = m;
 1ec:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <millis_timer_millis>
 1f0:	90 93 12 01 	sts	0x0112, r25	; 0x800112 <millis_timer_millis+0x1>
 1f4:	a0 93 13 01 	sts	0x0113, r26	; 0x800113 <millis_timer_millis+0x2>
 1f8:	b0 93 14 01 	sts	0x0114, r27	; 0x800114 <millis_timer_millis+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:116
  millis_timer_overflow_count++;
 1fc:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <millis_timer_overflow_count>
 200:	90 91 16 01 	lds	r25, 0x0116	; 0x800116 <millis_timer_overflow_count+0x1>
 204:	a0 91 17 01 	lds	r26, 0x0117	; 0x800117 <millis_timer_overflow_count+0x2>
 208:	b0 91 18 01 	lds	r27, 0x0118	; 0x800118 <millis_timer_overflow_count+0x3>
 20c:	01 96       	adiw	r24, 0x01	; 1
 20e:	a1 1d       	adc	r26, r1
 210:	b1 1d       	adc	r27, r1
 212:	80 93 15 01 	sts	0x0115, r24	; 0x800115 <millis_timer_overflow_count>
 216:	90 93 16 01 	sts	0x0116, r25	; 0x800116 <millis_timer_overflow_count+0x1>
 21a:	a0 93 17 01 	sts	0x0117, r26	; 0x800117 <millis_timer_overflow_count+0x2>
 21e:	b0 93 18 01 	sts	0x0118, r27	; 0x800118 <millis_timer_overflow_count+0x3>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:117
}
 222:	bf 91       	pop	r27
 224:	af 91       	pop	r26
 226:	9f 91       	pop	r25
 228:	8f 91       	pop	r24
 22a:	3f 91       	pop	r19
 22c:	2f 91       	pop	r18
 22e:	0f 90       	pop	r0
 230:	0f be       	out	0x3f, r0	; 63
 232:	0f 90       	pop	r0
 234:	1f 90       	pop	r1
 236:	18 95       	reti
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:111
    f -= FRACT_MAX;
    m = m + MILLIS_INC + 1;
  }
  else
  {
    m += MILLIS_INC;
 238:	02 96       	adiw	r24, 0x02	; 2
 23a:	a1 1d       	adc	r26, r1
 23c:	b1 1d       	adc	r27, r1
 23e:	d4 cf       	rjmp	.-88     	; 0x1e8 <__vector_11+0x3c>

00000240 <__vector_1>:
__vector_1():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/WInterrupts.c:124
  }
}

#if NUMBER_EXTERNAL_INTERRUPTS >= 1
ISR(EXTERNAL_INTERRUPT_0_vect)
{
 240:	1f 92       	push	r1
 242:	0f 92       	push	r0
 244:	0f b6       	in	r0, 0x3f	; 63
 246:	0f 92       	push	r0
 248:	11 24       	eor	r1, r1
 24a:	2f 93       	push	r18
 24c:	3f 93       	push	r19
 24e:	4f 93       	push	r20
 250:	5f 93       	push	r21
 252:	6f 93       	push	r22
 254:	7f 93       	push	r23
 256:	8f 93       	push	r24
 258:	9f 93       	push	r25
 25a:	af 93       	push	r26
 25c:	bf 93       	push	r27
 25e:	ef 93       	push	r30
 260:	ff 93       	push	r31
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/WInterrupts.c:125
  if(intFunc[EXTERNAL_INTERRUPT_0])
 262:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 266:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <_edata+0x1>
 26a:	89 2b       	or	r24, r25
 26c:	29 f0       	breq	.+10     	; 0x278 <__vector_1+0x38>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/WInterrupts.c:126
    intFunc[EXTERNAL_INTERRUPT_0]();
 26e:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <_edata>
 272:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <_edata+0x1>
 276:	09 95       	icall
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/WInterrupts.c:127
}
 278:	ff 91       	pop	r31
 27a:	ef 91       	pop	r30
 27c:	bf 91       	pop	r27
 27e:	af 91       	pop	r26
 280:	9f 91       	pop	r25
 282:	8f 91       	pop	r24
 284:	7f 91       	pop	r23
 286:	6f 91       	pop	r22
 288:	5f 91       	pop	r21
 28a:	4f 91       	pop	r20
 28c:	3f 91       	pop	r19
 28e:	2f 91       	pop	r18
 290:	0f 90       	pop	r0
 292:	0f be       	out	0x3f, r0	; 63
 294:	0f 90       	pop	r0
 296:	1f 90       	pop	r1
 298:	18 95       	reti

0000029a <main>:
main():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:491
  static uint8_t origOSC=0;

  uint8_t read_factory_calibration(void)
  {
    uint8_t SIGRD = 5; //Yes, this variable is needed. boot.h is looking for SIGRD but the io.h calls it RSIG... (unlike where this is needed in the other half of this core, at least the io.h file mentions it... ). Since it's actually a macro, not a function call, this works...
    uint8_t value = boot_signature_byte_get(1);
 29a:	81 e2       	ldi	r24, 0x21	; 33
 29c:	e1 e0       	ldi	r30, 0x01	; 1
 29e:	f0 e0       	ldi	r31, 0x00	; 0
 2a0:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
 2a4:	84 91       	lpm	r24, Z
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:560
    // jumping up about 174 from the factory cal gives us ~16 MHz at 4.5~5.25V - not always perfect, but should generally be close enough.
    origOSC=read_factory_calibration();
    oscBoost();
  #elif (CLOCK_SOURCE==0 && defined(LOWERCAL))
    origOSC=read_factory_calibration();
    oscSlow(origOSC-LOWERCAL);
 2a6:	81 50       	subi	r24, 0x01	; 1
oscSlow():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:495
    uint8_t SIGRD = 5; //Yes, this variable is needed. boot.h is looking for SIGRD but the io.h calls it RSIG... (unlike where this is needed in the other half of this core, at least the io.h file mentions it... ). Since it's actually a macro, not a function call, this works...
    uint8_t value = boot_signature_byte_get(1);
    return value;
  }
  void oscSlow(uint8_t newcal) {
    OSCCAL0=newcal;
 2a8:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__DATA_REGION_ORIGIN__+0x14>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:496
    _NOP(); //this is all micronucleus does, and it seems to work fine...
 2ac:	00 00       	nop
main():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:572
  #else
  CLKPR=1<<CLKPCE; //enable change of protected register
  #endif
  CLKPR=1; //prescale by 2 for 4MHz
  #endif
  sei();
 2ae:	78 94       	sei
Timer0_SetWaveformGenerationMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:140
}
timer0_wgm_t;

__attribute__((always_inline)) static inline void Timer0_SetWaveformGenerationMode( timer0_wgm_t wgm )
{
  TCCR0A = (TCCR0A & ~MASK2(WGM01,WGM00)) | (((wgm & B011) >> 0) << WGM00);
 2b0:	80 b7       	in	r24, 0x30	; 48
 2b2:	83 60       	ori	r24, 0x03	; 3
 2b4:	80 bf       	out	0x30, r24	; 48
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:141
  TCCR0B = (TCCR0B & ~MASK1(WGM02))       | (((wgm & B100) >> 2) << WGM02);
 2b6:	83 b7       	in	r24, 0x33	; 51
 2b8:	87 7f       	andi	r24, 0xF7	; 247
 2ba:	83 bf       	out	0x33, r24	; 51
Timer0_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:122
}
timer0_cs_t;

__attribute__((always_inline)) static inline void Timer0_ClockSelect( timer0_cs_t cs )
{
  TCCR0B = (TCCR0B & ~MASK3(CS02,CS01,CS00)) | (cs << CS00);
 2bc:	83 b7       	in	r24, 0x33	; 51
 2be:	88 7f       	andi	r24, 0xF8	; 248
 2c0:	83 60       	ori	r24, 0x03	; 3
 2c2:	83 bf       	out	0x33, r24	; 51
Timer0_EnableOverflowInterrupt():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:198
  TIMSK0 |= (1<<OCIE0A);
}

__attribute__((always_inline)) static inline void Timer0_EnableOverflowInterrupt( void )
{
  TIMSK0 |= (1<<TOIE0);
 2c4:	89 b7       	in	r24, 0x39	; 57
 2c6:	81 60       	ori	r24, 0x01	; 1
 2c8:	89 bf       	out	0x39, r24	; 57
Timer2_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:470
}
timer2_cs_t;

__attribute__((always_inline)) static inline void Timer2_ClockSelect( timer2_cs_t cs )
{
  TCCR2B = (TCCR2B & ~MASK3(CS22,CS21,CS20)) | (cs << CS20);
 2ca:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
 2ce:	88 7f       	andi	r24, 0xF8	; 248
 2d0:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
Timer2_SetWaveformGenerationMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:496
}
timer2_wgm_t;

__attribute__((always_inline)) static inline void Timer2_SetWaveformGenerationMode( timer2_wgm_t wgm )
{
  TCCR2A = (TCCR2A & ~MASK2(WGM21,WGM20)) | (((wgm & B0011) >> 0) << WGM20);
 2d4:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
 2d8:	8c 7f       	andi	r24, 0xFC	; 252
 2da:	81 60       	ori	r24, 0x01	; 1
 2dc:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:497
  TCCR2B = (TCCR2B & ~MASK2(WGM23,WGM22)) | (((wgm & B1100) >> 2) << WGM22);
 2e0:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
 2e4:	87 7e       	andi	r24, 0xE7	; 231
 2e6:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
Timer2_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:470
}
timer2_cs_t;

__attribute__((always_inline)) static inline void Timer2_ClockSelect( timer2_cs_t cs )
{
  TCCR2B = (TCCR2B & ~MASK3(CS22,CS21,CS20)) | (cs << CS20);
 2ea:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
 2ee:	88 7f       	andi	r24, 0xF8	; 248
 2f0:	83 60       	ori	r24, 0x03	; 3
 2f2:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
Timer1_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:282
}
timer1_cs_t;

__attribute__((always_inline)) static inline void Timer1_ClockSelect( timer1_cs_t cs )
{
  TCCR1B = (TCCR1B & ~MASK3(CS12,CS11,CS10)) | (cs << CS10);
 2f6:	8e b5       	in	r24, 0x2e	; 46
 2f8:	88 7f       	andi	r24, 0xF8	; 248
 2fa:	8e bd       	out	0x2e, r24	; 46
Timer1_SetWaveformGenerationMode():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:308
}
timer1_wgm_t;

__attribute__((always_inline)) static inline void Timer1_SetWaveformGenerationMode( timer1_wgm_t wgm )
{
  TCCR1A = (TCCR1A & ~MASK2(WGM11,WGM10)) | (((wgm & B0011) >> 0) << WGM10);
 2fc:	8f b5       	in	r24, 0x2f	; 47
 2fe:	8c 7f       	andi	r24, 0xFC	; 252
 300:	81 60       	ori	r24, 0x01	; 1
 302:	8f bd       	out	0x2f, r24	; 47
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:309
  TCCR1B = (TCCR1B & ~MASK2(WGM13,WGM12)) | (((wgm & B1100) >> 2) << WGM12);
 304:	8e b5       	in	r24, 0x2e	; 46
 306:	87 7e       	andi	r24, 0xE7	; 231
 308:	8e bd       	out	0x2e, r24	; 46
Timer1_ClockSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_timers.h:282
}
timer1_cs_t;

__attribute__((always_inline)) static inline void Timer1_ClockSelect( timer1_cs_t cs )
{
  TCCR1B = (TCCR1B & ~MASK3(CS12,CS11,CS10)) | (cs << CS10);
 30a:	8e b5       	in	r24, 0x2e	; 46
 30c:	88 7f       	andi	r24, 0xF8	; 248
 30e:	83 60       	ori	r24, 0x03	; 3
 310:	8e bd       	out	0x2e, r24	; 46
initTimer841():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:468
  Timer1_SetWaveformGenerationMode(1);
  Timer1_ClockSelect(3);

  #endif

  TOCPMSA0=0b00010000;
 312:	80 e1       	ldi	r24, 0x10	; 16
 314:	80 93 67 00 	sts	0x0067, r24	; 0x800067 <__DATA_REGION_ORIGIN__+0x7>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:469
  TOCPMSA1=0b10100100;
 318:	84 ea       	ldi	r24, 0xA4	; 164
 31a:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring.c:470
  TOCPMCOE=0b11111100;
 31e:	8c ef       	ldi	r24, 0xFC	; 252
 320:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <__DATA_REGION_ORIGIN__+0x6>
ADC_PrescalerSelect():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_adc.h:89
}
adc_ps_t;

__attribute__((always_inline)) static inline void ADC_PrescalerSelect( adc_ps_t ps )
{
  ADCSRA = (ADCSRA & ~MASK3(ADPS2,ADPS1,ADPS0)) | (ps << ADPS0);
 324:	85 b1       	in	r24, 0x05	; 5
 326:	88 7f       	andi	r24, 0xF8	; 248
 328:	86 60       	ori	r24, 0x06	; 6
 32a:	85 b9       	out	0x05, r24	; 5
ADC_Enable():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/core_adc.h:94
}

__attribute__((always_inline)) static inline void ADC_Enable( void )
{
  ADCSRA |= MASK1( ADEN );
 32c:	2f 9a       	sbi	0x05, 7	; 5
setup():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:6
#include <avr/sleep.h>

#include "Vars.h"

void setup() {
  pinMode(M1_PIN, OUTPUT);
 32e:	61 e0       	ldi	r22, 0x01	; 1
 330:	81 e0       	ldi	r24, 0x01	; 1
 332:	f3 de       	rcall	.-538    	; 0x11a <pinMode>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:7
  pinMode(M2_PIN, OUTPUT);
 334:	61 e0       	ldi	r22, 0x01	; 1
 336:	82 e0       	ldi	r24, 0x02	; 2
 338:	f0 de       	rcall	.-544    	; 0x11a <pinMode>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:8
  pinMode(M3_PIN, OUTPUT);
 33a:	61 e0       	ldi	r22, 0x01	; 1
 33c:	83 e0       	ldi	r24, 0x03	; 3
 33e:	ed de       	rcall	.-550    	; 0x11a <pinMode>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:10

  pinMode(B1_PIN, INPUT_PULLUP);
 340:	62 e0       	ldi	r22, 0x02	; 2
 342:	84 e0       	ldi	r24, 0x04	; 4
 344:	ea de       	rcall	.-556    	; 0x11a <pinMode>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:11
  pinMode(B2_PIN, INPUT_PULLUP);
 346:	62 e0       	ldi	r22, 0x02	; 2
 348:	85 e0       	ldi	r24, 0x05	; 5
 34a:	e7 de       	rcall	.-562    	; 0x11a <pinMode>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:15

  attachInterrupt(digitalPinToInterrupt(B1_PIN), wake, CHANGE);

  digitalWrite(M1_PIN, LOW);
 34c:	60 e0       	ldi	r22, 0x00	; 0
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	8c de       	rcall	.-744    	; 0x6a <digitalWrite>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:16
  digitalWrite(M2_PIN, LOW);
 352:	60 e0       	ldi	r22, 0x00	; 0
 354:	82 e0       	ldi	r24, 0x02	; 2
 356:	89 de       	rcall	.-750    	; 0x6a <digitalWrite>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:17
  digitalWrite(M3_PIN, LOW);
 358:	60 e0       	ldi	r22, 0x00	; 0
 35a:	83 e0       	ldi	r24, 0x03	; 3
 35c:	86 de       	rcall	.-756    	; 0x6a <digitalWrite>
next_motor():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:50
}

void next_motor(unsigned long curtime)
{
    digitalWrite(curmotor, LOW);
    delaymode = 1;
 35e:	01 e0       	ldi	r16, 0x01	; 1
 360:	10 e0       	ldi	r17, 0x00	; 0
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:58
    {
        curmotor = M2_PIN;
    }
    else if (curmotor == M2_PIN)
    {
        curmotor = M3_PIN;
 362:	83 e0       	ldi	r24, 0x03	; 3
 364:	88 2e       	mov	r8, r24
 366:	91 2c       	mov	r9, r1
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:54
    digitalWrite(curmotor, LOW);
    delaymode = 1;
    event_time = curtime + (spin_count * 3 + curmotor) * DELAY_MULTIPLIER;
    if (curmotor == M1_PIN)
    {
        curmotor = M2_PIN;
 368:	92 e0       	ldi	r25, 0x02	; 2
 36a:	a9 2e       	mov	r10, r25
 36c:	b1 2c       	mov	r11, r1
digitalRead():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:248
#endif

int digitalRead(uint8_t pin)
{
  if (pin&128) {pin=analogInputToDigitalPin((pin&127));}
  uint8_t bit = digitalPinToBitMask(pin);
 36e:	20 e4       	ldi	r18, 0x40	; 64
 370:	22 2e       	mov	r2, r18
 372:	20 e0       	ldi	r18, 0x00	; 0
 374:	32 2e       	mov	r3, r18
loop():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:91
    }
}

void loop()
{
    if (curmotor > 0)
 376:	c0 91 0e 01 	lds	r28, 0x010E	; 0x80010e <curmotor>
 37a:	d0 91 0f 01 	lds	r29, 0x010F	; 0x80010f <curmotor+0x1>
 37e:	1c 16       	cp	r1, r28
 380:	1d 06       	cpc	r1, r29
 382:	0c f0       	brlt	.+2      	; 0x386 <__stack+0x87>
 384:	50 c0       	rjmp	.+160    	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:93
    {
        unsigned long curtime = micros();
 386:	eb de       	rcall	.-554    	; 0x15e <micros>
 388:	6b 01       	movw	r12, r22
 38a:	7c 01       	movw	r14, r24
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:95

        if (curtime > event_time)
 38c:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <event_time>
 390:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <event_time+0x1>
 394:	a0 91 0c 01 	lds	r26, 0x010C	; 0x80010c <event_time+0x2>
 398:	b0 91 0d 01 	lds	r27, 0x010D	; 0x80010d <event_time+0x3>
 39c:	8c 15       	cp	r24, r12
 39e:	9d 05       	cpc	r25, r13
 3a0:	ae 05       	cpc	r26, r14
 3a2:	bf 05       	cpc	r27, r15
 3a4:	08 f0       	brcs	.+2      	; 0x3a8 <__stack+0xa9>
 3a6:	3f c0       	rjmp	.+126    	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
next_event():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:77
    }
}

void next_event(unsigned long curtime)
{
    if (delaymode == 0)
 3a8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <delaymode>
 3ac:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <delaymode+0x1>
 3b0:	89 2b       	or	r24, r25
 3b2:	09 f0       	breq	.+2      	; 0x3b6 <__stack+0xb7>
 3b4:	94 c0       	rjmp	.+296    	; 0x4de <__LOCK_REGION_LENGTH__+0xde>
next_motor():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:49
    event_time = micros() + MOTOR_RUN_TIME;
}

void next_motor(unsigned long curtime)
{
    digitalWrite(curmotor, LOW);
 3b6:	60 e0       	ldi	r22, 0x00	; 0
 3b8:	8c 2f       	mov	r24, r28
 3ba:	57 de       	rcall	.-850    	; 0x6a <digitalWrite>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:50
    delaymode = 1;
 3bc:	10 93 03 01 	sts	0x0103, r17	; 0x800103 <delaymode+0x1>
 3c0:	00 93 02 01 	sts	0x0102, r16	; 0x800102 <delaymode>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:51
    event_time = curtime + (spin_count * 3 + curmotor) * DELAY_MULTIPLIER;
 3c4:	40 90 04 01 	lds	r4, 0x0104	; 0x800104 <spin_count>
 3c8:	50 90 05 01 	lds	r5, 0x0105	; 0x800105 <spin_count+0x1>
 3cc:	60 90 06 01 	lds	r6, 0x0106	; 0x800106 <spin_count+0x2>
 3d0:	70 90 07 01 	lds	r7, 0x0107	; 0x800107 <spin_count+0x3>
 3d4:	23 e0       	ldi	r18, 0x03	; 3
 3d6:	30 e0       	ldi	r19, 0x00	; 0
 3d8:	40 e0       	ldi	r20, 0x00	; 0
 3da:	50 e0       	ldi	r21, 0x00	; 0
 3dc:	c3 01       	movw	r24, r6
 3de:	b2 01       	movw	r22, r4
 3e0:	a5 d0       	rcall	.+330    	; 0x52c <__mulsi3>
 3e2:	9e 01       	movw	r18, r28
 3e4:	0d 2e       	mov	r0, r29
 3e6:	00 0c       	add	r0, r0
 3e8:	44 0b       	sbc	r20, r20
 3ea:	55 0b       	sbc	r21, r21
 3ec:	62 0f       	add	r22, r18
 3ee:	73 1f       	adc	r23, r19
 3f0:	84 1f       	adc	r24, r20
 3f2:	95 1f       	adc	r25, r21
 3f4:	26 eb       	ldi	r18, 0xB6	; 182
 3f6:	33 e0       	ldi	r19, 0x03	; 3
 3f8:	40 e0       	ldi	r20, 0x00	; 0
 3fa:	50 e0       	ldi	r21, 0x00	; 0
 3fc:	97 d0       	rcall	.+302    	; 0x52c <__mulsi3>
 3fe:	c6 0e       	add	r12, r22
 400:	d7 1e       	adc	r13, r23
 402:	e8 1e       	adc	r14, r24
 404:	f9 1e       	adc	r15, r25
 406:	c0 92 0a 01 	sts	0x010A, r12	; 0x80010a <event_time>
 40a:	d0 92 0b 01 	sts	0x010B, r13	; 0x80010b <event_time+0x1>
 40e:	e0 92 0c 01 	sts	0x010C, r14	; 0x80010c <event_time+0x2>
 412:	f0 92 0d 01 	sts	0x010D, r15	; 0x80010d <event_time+0x3>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:52
    if (curmotor == M1_PIN)
 416:	c1 30       	cpi	r28, 0x01	; 1
 418:	d1 05       	cpc	r29, r1
 41a:	09 f0       	breq	.+2      	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
 41c:	3c c0       	rjmp	.+120    	; 0x496 <__LOCK_REGION_LENGTH__+0x96>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:54
    {
        curmotor = M2_PIN;
 41e:	b0 92 0f 01 	sts	0x010F, r11	; 0x80010f <curmotor+0x1>
 422:	a0 92 0e 01 	sts	0x010E, r10	; 0x80010e <curmotor>
digitalRead():
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:248
 426:	f1 01       	movw	r30, r2
 428:	84 91       	lpm	r24, Z
/home/micha/.arduino15/packages/ATTinyCore/hardware/avr/1.5.2/cores/tinymodern/wiring_digital.c:259
  // "read" should *NEVER* change the behavior of the thing you're using it on.
  // That's why it's called "read" not "write". As an added bonus, sets the
  // stage for auto-fast-digitalRead() for compile time known pins.
  // turnOffPWM( pin );

  if (*portInputRegister(port) & bit) return HIGH;
 42a:	99 b3       	in	r25, 0x19	; 25
 42c:	89 23       	and	r24, r25
 42e:	09 f4       	brne	.+2      	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
 430:	6c c0       	rjmp	.+216    	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>
loop():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:105

    if (digitalRead(B1_PIN) == BTN_ON)
    {
        b1down = 1;
    }
    else if (b1down)
 432:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <b1down>
 436:	90 91 09 01 	lds	r25, 0x0109	; 0x800109 <b1down+0x1>
 43a:	89 2b       	or	r24, r25
 43c:	09 f4       	brne	.+2      	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
 43e:	69 c0       	rjmp	.+210    	; 0x512 <__LOCK_REGION_LENGTH__+0x112>
restart_motors():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:37

//int debounce = 0;

void restart_motors()
{
    spin_count = 0;
 440:	10 92 04 01 	sts	0x0104, r1	; 0x800104 <spin_count>
 444:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <spin_count+0x1>
 448:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <spin_count+0x2>
 44c:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <spin_count+0x3>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:38
    if (curmotor == 0)
 450:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <curmotor>
 454:	90 91 0f 01 	lds	r25, 0x010F	; 0x80010f <curmotor+0x1>
 458:	89 2b       	or	r24, r25
 45a:	39 f4       	brne	.+14     	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:40
    {
        curmotor = M1_PIN;
 45c:	10 93 0f 01 	sts	0x010F, r17	; 0x80010f <curmotor+0x1>
 460:	00 93 0e 01 	sts	0x010E, r16	; 0x80010e <curmotor>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:41
        digitalWrite(curmotor, HIGH);
 464:	61 e0       	ldi	r22, 0x01	; 1
 466:	81 e0       	ldi	r24, 0x01	; 1
 468:	00 de       	rcall	.-1024   	; 0x6a <digitalWrite>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:43
    }
    delaymode = 0;
 46a:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <delaymode+0x1>
 46e:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <delaymode>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:44
    event_time = micros() + MOTOR_RUN_TIME;
 472:	75 de       	rcall	.-790    	; 0x15e <micros>
 474:	68 57       	subi	r22, 0x78	; 120
 476:	7c 4e       	sbci	r23, 0xEC	; 236
 478:	8f 4f       	sbci	r24, 0xFF	; 255
 47a:	9f 4f       	sbci	r25, 0xFF	; 255
 47c:	60 93 0a 01 	sts	0x010A, r22	; 0x80010a <event_time>
 480:	70 93 0b 01 	sts	0x010B, r23	; 0x80010b <event_time+0x1>
 484:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <event_time+0x2>
 488:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <event_time+0x3>
loop():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:108
        b1down = 1;
    }
    else if (b1down)
    {
        restart_motors();
        b1down = 0;
 48c:	10 92 09 01 	sts	0x0109, r1	; 0x800109 <b1down+0x1>
 490:	10 92 08 01 	sts	0x0108, r1	; 0x800108 <b1down>
 494:	3e c0       	rjmp	.+124    	; 0x512 <__LOCK_REGION_LENGTH__+0x112>
next_motor():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:56
    event_time = curtime + (spin_count * 3 + curmotor) * DELAY_MULTIPLIER;
    if (curmotor == M1_PIN)
    {
        curmotor = M2_PIN;
    }
    else if (curmotor == M2_PIN)
 496:	22 97       	sbiw	r28, 0x02	; 2
 498:	29 f4       	brne	.+10     	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:58
    {
        curmotor = M3_PIN;
 49a:	90 92 0f 01 	sts	0x010F, r9	; 0x80010f <curmotor+0x1>
 49e:	80 92 0e 01 	sts	0x010E, r8	; 0x80010e <curmotor>
 4a2:	c1 cf       	rjmp	.-126    	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:63
    }
    else
    {
        // curmotor == M3_PIN
        ++spin_count;
 4a4:	8f ef       	ldi	r24, 0xFF	; 255
 4a6:	48 1a       	sub	r4, r24
 4a8:	58 0a       	sbc	r5, r24
 4aa:	68 0a       	sbc	r6, r24
 4ac:	78 0a       	sbc	r7, r24
 4ae:	40 92 04 01 	sts	0x0104, r4	; 0x800104 <spin_count>
 4b2:	50 92 05 01 	sts	0x0105, r5	; 0x800105 <spin_count+0x1>
 4b6:	60 92 06 01 	sts	0x0106, r6	; 0x800106 <spin_count+0x2>
 4ba:	70 92 07 01 	sts	0x0107, r7	; 0x800107 <spin_count+0x3>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:64
        if (spin_count >= 12)
 4be:	ec e0       	ldi	r30, 0x0C	; 12
 4c0:	4e 16       	cp	r4, r30
 4c2:	51 04       	cpc	r5, r1
 4c4:	61 04       	cpc	r6, r1
 4c6:	71 04       	cpc	r7, r1
 4c8:	28 f0       	brcs	.+10     	; 0x4d4 <__LOCK_REGION_LENGTH__+0xd4>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:66
        {
            curmotor = 0;
 4ca:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <curmotor+0x1>
 4ce:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <curmotor>
 4d2:	a9 cf       	rjmp	.-174    	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:70
        }
        else
        {
            curmotor = M1_PIN;
 4d4:	10 93 0f 01 	sts	0x010F, r17	; 0x80010f <curmotor+0x1>
 4d8:	00 93 0e 01 	sts	0x010E, r16	; 0x80010e <curmotor>
 4dc:	a4 cf       	rjmp	.-184    	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
next_event():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:83
    {
        next_motor(curtime);
    }
    else
    {
        digitalWrite(curmotor, HIGH);
 4de:	61 e0       	ldi	r22, 0x01	; 1
 4e0:	8c 2f       	mov	r24, r28
 4e2:	c3 dd       	rcall	.-1146   	; 0x6a <digitalWrite>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:84
        event_time = curtime + MOTOR_RUN_TIME;
 4e4:	f8 e8       	ldi	r31, 0x88	; 136
 4e6:	cf 0e       	add	r12, r31
 4e8:	f3 e1       	ldi	r31, 0x13	; 19
 4ea:	df 1e       	adc	r13, r31
 4ec:	e1 1c       	adc	r14, r1
 4ee:	f1 1c       	adc	r15, r1
 4f0:	c0 92 0a 01 	sts	0x010A, r12	; 0x80010a <event_time>
 4f4:	d0 92 0b 01 	sts	0x010B, r13	; 0x80010b <event_time+0x1>
 4f8:	e0 92 0c 01 	sts	0x010C, r14	; 0x80010c <event_time+0x2>
 4fc:	f0 92 0d 01 	sts	0x010D, r15	; 0x80010d <event_time+0x3>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:85
        delaymode = 0;
 500:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <delaymode+0x1>
 504:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <delaymode>
 508:	8e cf       	rjmp	.-228    	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
loop():
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:103
        }
    }

    if (digitalRead(B1_PIN) == BTN_ON)
    {
        b1down = 1;
 50a:	10 93 09 01 	sts	0x0109, r17	; 0x800109 <b1down+0x1>
 50e:	00 93 08 01 	sts	0x0108, r16	; 0x800108 <b1down>
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:110
    else if (b1down)
    {
        restart_motors();
        b1down = 0;
    }
    ADCSRA = 0;  
 512:	15 b8       	out	0x05, r1	; 5
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:112

    set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 514:	85 b7       	in	r24, 0x35	; 53
 516:	87 7e       	andi	r24, 0xE7	; 231
 518:	80 61       	ori	r24, 0x10	; 16
 51a:	85 bf       	out	0x35, r24	; 53
/home/micha/Git Repos/E-Fidget/Firmware/E-Fidget-Current/E-Fidget-Test/E-Fidget-Test.ino:113
    sleep_mode();
 51c:	85 b7       	in	r24, 0x35	; 53
 51e:	80 62       	ori	r24, 0x20	; 32
 520:	85 bf       	out	0x35, r24	; 53
 522:	88 95       	sleep
 524:	85 b7       	in	r24, 0x35	; 53
 526:	8f 7d       	andi	r24, 0xDF	; 223
 528:	85 bf       	out	0x35, r24	; 53
 52a:	25 cf       	rjmp	.-438    	; 0x376 <__stack+0x77>

0000052c <__mulsi3>:
__mulsi3():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:445
 52c:	ee 27       	eor	r30, r30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:446
 52e:	ff 27       	eor	r31, r31

00000530 <__mulsi3_helper>:
__mulsi3_helper():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:451
 530:	aa 27       	eor	r26, r26
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:452
 532:	bb 27       	eor	r27, r27
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:453
 534:	08 c0       	rjmp	.+16     	; 0x546 <__mulsi3_helper+0x16>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:457
 536:	a2 0f       	add	r26, r18
 538:	b3 1f       	adc	r27, r19
 53a:	e4 1f       	adc	r30, r20
 53c:	f5 1f       	adc	r31, r21
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:460
 53e:	22 0f       	add	r18, r18
 540:	33 1f       	adc	r19, r19
 542:	44 1f       	adc	r20, r20
 544:	55 1f       	adc	r21, r21
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:463
 546:	96 95       	lsr	r25
 548:	87 95       	ror	r24
 54a:	77 95       	ror	r23
 54c:	67 95       	ror	r22
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:465
 54e:	98 f3       	brcs	.-26     	; 0x536 <__mulsi3_helper+0x6>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:467
 550:	70 40       	sbci	r23, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:468
 552:	a9 f7       	brne	.-22     	; 0x53e <__mulsi3_helper+0xe>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:469
 554:	00 97       	sbiw	r24, 0x00	; 0
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:470
 556:	99 f7       	brne	.-26     	; 0x53e <__mulsi3_helper+0xe>
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:473
 558:	bd 01       	movw	r22, r26
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:474
 55a:	cf 01       	movw	r24, r30
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:480
 55c:	08 95       	ret

0000055e <_exit>:
exit():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 55e:	f8 94       	cli

00000560 <__stop_program>:
__stop_program():
/home/jenkins/workspace/avr-gcc-staging/label/debian7-x86_64/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 560:	ff cf       	rjmp	.-2      	; 0x560 <__stop_program>
